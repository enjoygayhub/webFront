# 计算机网络 与HTTP


## OSI七层与TCP/IP五层模型

- OSI七层模型

  ```txt
  物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）
  数据链路层：将比特组装成帧和点到点的传递（帧Frame）
  网络层：负责数据包从源到宿的传递和网际互连（包PackeT）
  传输层：提供端到端的可靠报文传递和错误恢复（段Segment）
  会话层：建立、管理和终止会话（会话协议数据单元SPDU）
  表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）
  应用层：允许访问OSI环境的手段（应用协议数据单元APDU）
  ```

- TCP/IP五层模型

  ```txt
  应用层：TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet
  传输层：TCP，UDP
  网络层：IP，ICMP，RIP，OSPF，BGP，IGMP
  数据链路层：SLIP，CSLIP，PPP，ARP，RARP，MTU
  物理层
  ```

## 应用层的协议哪些是基于TCP协议的，哪些是基于UDP协议的

### 基于TCP协议的

- FTP（文件传输协议）：定义了文件传输协议，使用21端口。
- TELNET（远程登陆协议）：一种用于远程登陆的端口，使用23端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务。
- SMTP（简单邮件传输协议）：邮件传送协议，用于发送邮件。服务器开放的是25号端口。
- POP3（邮件读取协议）：它是和SMTP对应，POP3用于接收邮件。POP3协议所用的是110端口。
- HTTP（超文本传输协议）：是从Web服务器传输超文本到本地浏览器的传送协议。
- HTTPS（超文本传输安全协议）

### 基于UDP协议的

- TFTP（简单文件传输协议）：该协议在熟知端口69上使用UDP服务。
- SNMP（简单网络管理协议）：使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。
- BOOTP（引导程序协议，DHCP的前身）：应用于无盘设备
- DHCP（动态主机配置协议）：是一个局域网的网络协议
- RIP（路由信息协议）：基于距离矢量算法的路由协议，利用跳数来作为计量标准。
- IGMP（Internet组管理协议）


## TCP 和 UDP 之间的区别

TCP：传输控制协议 UDP：用户数据报协议

1. TCP 是面向连接的，UDP 是无连接的即发送数据前不需要先建立链接；
2. TCP 提供可靠的服务。也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP 尽最大努力交付，即不保证可靠交付。
3. TCP 是面向字节流，UDP 面向报文；
4. TCP 只能是 1 对 1 的，UDP 支持 1 对 1,1 对多；
5. TCP 的首部较大为 20 字节，而 UDP 只有 8 字节；

## TCP 的三次握手和四次挥手

三次握手：
第一次握手：客户端发送syn包(syn=1，seq=x)到服务器，并进入SYN_SENT状态，等待服务器确认；
第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态；
第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。
握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。
四次挥手
与建立连接的“三次握手”类似，断开一个TCP连接则需要“四次挥手”。
第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。
第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。
第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。
第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。

## ARP地址解析协议

1：首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。
2：当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：源主机 IP地址，源主机MAC地址，目的主机的IP 地址。
3：当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。
4：源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。
广播发送ARP请求，单播发送ARP响应。

## 对称加密和非对称加密的区别

- 对称加密: 加密和解密的秘钥使用的是同一个.
- 非对称加密: 与对称加密算法不同，非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）

对称加密算法: 密钥较短，破译困难，除了数据加密标准（DES），另一个对称密钥加密系统是国际数据加密算法（IDEA），它比DES的加密性好，且对计算机性能要求也没有那么高.

优点:算法公开、计算量小、加密速度快、加密效率高

缺点:在数据传送前，发送方和接收方必须商定好秘钥，然后 使双方都能保存好秘钥。其次如果一方的秘钥被泄露，那么加密信息也就不安全了。另外，每对用户每次使用对称加密算法时，都需要使用其他人不知道的唯一秘钥，这会使得收、发双方所拥有的钥匙数量巨大，密钥管理成为双方的负担。

常见的对称加密算法有: DES、3DES、Blowfish、IDEA、RC4、RC5、RC6 和 AES 

非对称加密算法: 公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。

非对称加密算法实现机密信息交换的基本过程是：甲方生成一对密钥并将其中的一把作为公用密钥向其它方公开；得到该公用密钥的乙方使用该密钥对机密信息进行加密后再发送给甲方；甲方再用自己保存的另一把专用密钥对加密后的信息进行解密。甲方只能用其专用密钥解密由其公用密钥加密后的任何信息。

优点:安全

缺点:速度较慢

常见的非对称加密算法有: RSA、ECC（移动设备用）、Diffie-Hellman、El Gamal、DSA（数字签名用）
原文链接：https://blog.csdn.net/qq_29689487/article/details/81634057

## ip地址分类

A类地址：以0开头，  第一个字节范围：1~126（1.0.0.0 - 126.255.255.255）；

B类地址：以10开头，  第一个字节范围：128~191（128.0.0.0 - 191.255.255.255）；

C类地址：以110开头， 第一个字节范围：192~223（192.0.0.0 - 223.255.255.255）；

D类地址：以1110开头，第一个字节范围：224~239（224.0.0.0 - 239.255.255.255）；（作为多播使用）

E类地址：保留

以下是留用的内部私有地址：

A类 1个 10.0.0.0--10.255.255.255

B类  16个 172.16.0.0--172.31.255.255

C类  255个 192.168.0.0--192.168.255.255




## 浏览器输入 URL 之后发生了什么

> 参考链接：[在浏览器输入 URL 回车之后发生了什么（超详细版）](https://4ark.me/post/b6c7c0a2.html)

1. DNS 解析
2. TCP 连接
3. 发送 HTTP 请求
4. 服务器处理请求并返回 HTTP 报文
5. 浏览器解析渲染页面
6. 连接结束

## DNS 的具体过程

1. 输入 IP，此时电脑发送一个 DNS 请求到本地 DNS 服务器（一般是网络接入服务商提供 eg:电信，移动）
2. 本地 DNS 服务器会首先查询它的缓存记录，若有，则直接返回结果，若没有，本地 DNS 服务器还要向 DNS 根服务器进行查询；
3. DNS 根服务器没有记录具体域名和 IP 地址的对应关系，而是告诉本地 DNS 服务器，可到域服务器上继续查询，并给出域服务器地址
4. 本地服务器继续向域服务器发出请求，返回域名的解析服务器地址
5. 本地 DNS 向域名解析服务器发出请求，收到域名与 IP 地址对应关系
6. 本地 DNS 服务器将 IP 地址返回电脑，且保存副本到缓存已备下次查询



## cookie 和 session 的区别

1.存储位置不同：
> cookie 数据存放在客户的浏览器上
> session 数据放在服务器上。

2.存储容量不同：

> 单个 cookie 保存的数据不能超过 4K，一个站点最多保存 20 个 cookie。
> 对于 session 来说并没有上限，但出于对服务器端的性能考虑，session 内不要存放过多的东西，并且设置 session 删除机制。

3.存储方式不同：

> cookie 中只能保管 ASCII 字符串，并需要通过编码方式存储为 Unicode 字符或者二进制数据。
> session 中能够存储任何类型的数据，包括且不限于 string，integer，list，map 等。

4.隐私策略不同
> cookie 对客户端是可见的，别有用心的人可以分析存放在本地的 cookie 并进行 cookie 欺骗，所以它是不安全的。
> session 存储在服务器上，不存在敏感信息泄漏的风险。

5.有效期不同

> cookie 保管在客户端，不占用服务器资源。对于并发用户十分多的网站，cookie 是很好的选择。
> session 是保管在服务器端的，每个用户都会产生一个 session。假如并发访问的用户十分多，会产生十分多的 session，耗费大量的内存。

## Ajax， fetch，XHR

Ajax 是一种技术集合，所以Fetch也是Ajax的一个子集，在之前，我们常说Ajax 默认是指以XHR为核心的技术合集
XHR 以 XMLHttpRequest对象为核心
同源下：XHR，fetch 都支持cookie,非同源：无论xhr还是fetch都是不自动带cookie
无论fetch 还是 XHR 都是在网络错误才会触发error


## 网络安全

1. XSS攻击(cross-site script)

   有两种主要的方法，注入恶意的脚本，返回到浏览器运行 ：
  + 反射型：如果客户端将用户输入信息带入代码中，比如在输入的搜索的关键词、图片的链接后附带脚本，被编码进html代码中，浏览器会执行附带的脚本代码 
  + 持久型 ：服务端保存了用户的携带恶意代码的评论，其他的用户浏览到该评论时就可能会执行。

  防范 XSS 攻击的最好方式就是删除或禁用任何可能包含可运行代码指令的标记。对 HTML 来说，这些包括类似 <script>, <object>, <embed>,和 <link> 的标签。对用户的输入过滤

2. CSRF攻击(cross site request forgery,跨站请求伪造)

在其他站点伪造post请求，如果用户登录过，浏览器可能会记录cookie，在请求时便携带上了。便可以以用户的名义进行非法操作。
不过现代浏览器跨域的网络请求不会携带cookie。
服务端一般都会与token身份验证，token可以保证用户不同设备登录互踢，后端可以确认请求中没有token便会返回未授权。

3. SQL注入

当传递给底层 SQL 语句的用户输入可以修改该语句的语义，那么就能执行恶意的sql操作。
所以需要将用户输入中任何在 SQL 语句中有特殊含义的字符进行转义。

4. 劫持

将站点链到隐藏的iframe里，劫持上层的操作，转发给隐藏的iframe。从而执行恶意操作。
作为防范手段，可以通过设置适当的 HTTP 头来防止其被嵌入到另一个站点的 iframe 中。

5. 拒绝服务 DoS
Dos 通常通过使用伪造的请求淹没站点，合法用户的访问就会被中断。这些请求可能仅仅是数量巨大或者是单独消耗了大量资源 (如 延缓读，上传大文件等) 。


# HTTP

HTTP 本质是无状态的，使用 Cookies 可以创建有状态的会话。
## 资源定位URI

协议：http://
主机: www.xx.com
端口: :80 (标准端口HTTP 为 80，HTTPS 为 443)
路径: /path/myfile.html
查询: ?key1=value1&key2=value2 
片段：#SomewhereInTheDocument（# 号后面的部分，称为片段标识符，永远不会与请求一起发送到服务器。）

## MIME类型

媒体类型（通常称为 Multipurpose Internet Mail Extensions 或 MIME 类型）是一种标准，用来表示文档、文件或字节流的性质和格式
text/plain，image/png，audio/ogg，video/mp4，application/javascript（二进制数据）

## 代理主要有如下几种作用：

缓存（可以是公开的也可以是私有的，像浏览器的缓存）
过滤（像反病毒扫描，家长控制...）
负载均衡（让多个服务器服务不同的请求）
认证（对不同资源进行权限管理）
日志记录（允许存储历史信息）

## HTTP的发展

### HTTP/1.1
1. 连接可以复用，节省了多次打开 TCP 连接加载网页文档资源的时间。
2. 增加管线化技术，允许在第一个应答被完全发送之前就发送第二个请求，以降低通信延迟。
3. 支持响应分块。
4. 引入额外的缓存控制机制。
5. 引入内容协商机制，包括语言，编码，类型等，并允许客户端和服务器之间约定以最合适的内容进行交换。
6. 凭借Host头，能够使不同域名配置在同一个 IP 地址的服务器上。

### HTTP/2.0
> 参考链接：[HTTP/2 相比 1.0 有哪些重大改进？](https://www.zhihu.com/question/34074946)

1. 首部压缩
2. 多路复用
3. 二进制分帧
4. 服务端推送

## HTTP 状态码

1. 1XX 信息性状态码
   - 100 Continue继续
   - 101 Switching Protocol切换协议 例如使用websocket时需要切换
2. 2XX 成功状态码
   - 200 OK 成功处理了请求
   - 204 No Content 请求处理成功，但没有资源可返回
   - 206 Partial Content 请求资源的某一部分
3. 3XX 重定向状态码
   - 301 Moved Permanently 永久性重定向，表示请求的资源已被分配了新的 URI，与308类似
   - 302 Found 临时性重定向，资源的 URL 已临时定位到其他位置，与307类似
   - 303 See Other，告诉客户端应该用另一个 URL 获取资源
   - 304 Not Modified 未改变，告诉客户端使用缓存 
4. 4XX 客户端错误状态码
   - 400 Bad Request 由于语法无效，服务器无法理解该请求
   - 401 Unauthorized 未授权
   - 403 Forbidden 服务器拒绝了请求
   - 404 Not Found 服务器无法找到所请求的资源
5. 5XX 服务器错误状态码
   - 500 Internal Server Error内部服务器错误
   - 502 Bad Gateway 错误网关
   - 503 Service Unavailable 服务器暂时处于超负载或正在进行停机维护，无法处理请求。
   - 504 Gateway Timeout 响应超时

## HTTP 与 HTTPS 的区别

1. HTTP 传输的数据是明文未加密的，HTTPS 协议是由 HTTP 和 SSL 协议构建的可进行加密传输和身份认证的网络协议，安全性更高。
2. HTTPS 协议需要 CA 证书
3. 使用不同的链接方式，默认使用端口也不同，一般而言，HTTP 协议的端口为 80，HTTPS 的端口为 443；在网络模型中，HTTP工作于应用层，而HTTPS工作在传输层。

## HTTPS 协议的工作流程

1. 客户使用 HTTPS URL 访问服务器，则要求 web 服务器建立 SSL 链接。
2. web 服务器接收到客户端的请求之后，会将网站的证书（证书中包含了公钥），返回给客户端。
3. 客户端和 web 服务器端开始协商 SSL 链接的安全等级，也就是加密等级。
4. 客户端浏览器通过双方协商一致的安全等级，建立会话密钥，然后通过网站的公钥来加密会话密钥，并传送给网站。
5. web 服务器通过自己的私钥解密出会话密钥。
6. web 服务器通过会话密钥加密与客户端之间进行通信。

## HTTP 请求方法

1. GET：请求指定的页面信息，并返回实体主体。
2. HEAD：类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头
3. POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求body中。
4. PUT：从客户端向服务器传送的数据取代指定的文档的内容。
5. DELETE：请求服务器删除指定的页面。
6. CONNECT：HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。
7. OPTIONS：允许客户端查看服务器的性能。
8. TRACE：回显服务器收到的请求，主要用于测试或诊断。

## GET 和 POST 的区别

两者本质上都是 TCP 链接

1. get 参数通过 url 传递，post 放在请求体 (request body) 中。
2. get 请求在 url 中传递的参数是有长度限制的，而 post 没有。
3. get 比 post 更不安全，因为参数直接暴露在 url 中，所以不能用来传递敏感信息。
4. get 请求只能进行 url 编码，而 post 支持多种编码方式。
5. get 请求参数会被完整保留在浏览历史记录里，而 post 中的参数不会被保留。
6. get 产生一个 TCP 数据包；post 产生两个 TCP 数据包。
   对于 get 方式的请求，浏览器会把 http header 和 data 一并发送出去，服务器响应 200（返回数据）；
   而对于 post，浏览器先发送 header，服务器响应 100 continue，浏览器再发送 data，服务器响应 200 ok（返回数据）。

## 浏览器的同源政策

协议、域名、端口号必须相同，否则则不属于同一个域。

同源政策主要限制了三个方面
第一当前域下的 js 脚本不能够访问其他域下的localStorage 和 indexDB。
第二当前域下的 js 脚本不能够操作访问其他域下的 DOM。
第三当前域下 ajax 无法发送跨域请求。

## 跨源资源共享（CORS）需要的场景

1.  XMLHttpRequest 或 Fetch API 发起的跨域 HTTP 请求。
2. Web 字体。
3. WebGL 贴图。
4. 使用 drawImage() 将图片或视频画面绘制到 canvas。
5. 来自图像的 CSS 图形 (en-US)。

## 网络请求跨域

> 当一个请求url的 协议、域名、端口三者之间任意一个与当前页面url不同即为跨域。

1. JSONP (JSON with Padding) 通过动态创建 script，再请求一个带参网址实现跨域通信，目前已过时。

2. CORS (跨域资源共享)
    CORS的基本思想就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是失败。

    简单请求：只需服务端设置 `Access-Control-Allow-Origin：*` 即可，若要带 cookie 请求：前后端都需要设置。前端设置`withCredentials`为true,后端设置`Access-Control-Allow-Credentials`为true,同时`Access-Control-Allow-Origin`不能设置为`*`
    复杂请求：使用 OPTIONS 方法发起一个预检请求到服务器，告知服务器实际请求使用方法和首部自定义字段，服务端响应返回实际请求接受的域和方法，头部。如果要携带cookie，Access-Control-Allow-Origin，Access-Control-Allow-Headers，Access-Control-Allow-Methods 均不能设置为*。
3. nginx反向代理,服务端请求不受浏览器限制，既访问同源服务端，服务端再去寻找正在的地址拿到数据再返回
4. webpack正向代理， 客户端配置正向代理，替换表面访问地址。
5. WebSocket协议跨域

## 缓存

1. 私有缓存：浏览器缓存的个性化信息
2. 共享缓存：
    + 代理缓存
    + 托管缓存：包括反向代理，CDN，service worker 

### Expires 与 Cache-Control：max-age
HTTP/1.0 中的Expires 
Expires 的值是一个绝对时间的 GMT 格式的时间字符串。比如 Expires 值是：`expires:Fri, 14 Apr 2017 10:47:02 GMT`。这个时间代表这这个资源的失效时间，只要发送请求时间是在 Expires 之前，那么本地缓存始终有效，则在缓存中读取数据。

HTTP/1.1 中，Cache-Control指定 max-age——代表经过的时间后缓存过期。
同时启用的时候 Cache-Control 优先级高。

### 缓存重新验证响应 

`Etag/If-None-Match`返回的是一个校验码。`Etag`可以保证每一个资源是唯一的，资源变化都会导致`Etag`变化。服务器根据浏览器发送的`If-None-Match`值来判断是否命中缓存。

Last-Modify是一个时间标识该资源的最后修改时间，例如Last-Modify: Thu,31 Dec 2037 23:59:59 GMT。当浏览器再次请求该资源时，request的请求头中会包含If-Modify-Since，该值为缓存之前返回Last-Modify。服务器收到If-Modify-Since后，根据资源的最后修改时间判断是否命中缓存。如果命中缓存，则返回304，并且不会返回资源内容，并且不会返回Last-Modify。

`Last-Modified` 与 `ETag` 是可以一起使用的，服务器会优先验证`ETag`，一致的情况下，才会继续比对 `Last-Modified`，最后才决定是否返回 304。

### 不使用缓存 Cache-Control

no-cache 指令不会阻止响应的存储，而是阻止在没有重新验证的情况下重用响应。
no-store 响应不存储在任何缓存中
private 私有缓存