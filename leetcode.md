# leetcode


## 1. [两数之和](https://leetcode-cn.com/problems/two-sum)

- 两层循环

```txt
时间复杂度：O(N^2)
空间复杂度：O(1)
```

```js
var twoSum = function(nums, target) {
    for(let i=0; i<nums.length; i++) {
        let n1 = nums[i];
        let n2 = target - n1;
        let index = nums.indexOf(n2);
        if (index !== i && index !== -1) {
            return [i, index]
        }
    }
};
```

- 哈希map

```txt
map用来存储遍历时候的元素-索引对
遍历一次列表，计算每个元素与target的差，判断一下map中存不存在这个键
时间复杂度：O(N)
空间复杂度：O(N)

举例：
  nums = [2, 7, 11, 15]， target = 9

  遍历第一轮：i = 0
    num = 9 - 2 = 7,
    7在map中不存在,将当前遍历元素添加进map，map = { 2: 0 }

  遍历第二轮： i = 1
    num = 9 - 7 = 2,
    2在map中是键，直接返回2对应值和当前的索引组成的数组 [0, 1]
```

```js
var twoSum = function(nums, target) {
    let map = new Map();
    for (let i = 0; i < nums.length; i++) {
        let num = target - nums[i];
        if (map.has(num)) {
            return [map.get(num), i];
        } else {
            map.set(nums[i], i);
        }
    }
};
```

## 2. [两数相加](https://leetcode-cn.com/problems/add-two-numbers/)

```txt
同时循环两个链表，并用一个标志位来控制进位，模拟计算过程即可。

时间复杂度：O(max{m, n})，m 和 n 分别表示两个链表的长度
空间复杂度：O(max{m, n})
```

```js
var addTwoNumbers = function(l1, l2) {
    let p1 = l1, p2 = l2;
    let pHead = new ListNode(-1);
    let head = pHead;
    let isAdd = 0;
    while(p1 || p2) {
        let n1 = p1 ? p1.val : 0;
        let n2 = p2 ? p2.val : 0;
        head.next = new ListNode((n1 + n2 + isAdd) % 10);
        n1 + n2 + isAdd > 9 ? (isAdd = 1) : (isAdd = 0);
        head = head.next;
        if (p1) p1 = p1.next;
        if (p2) p2 = p2.next;
    }
    if (isAdd === 1) {
        head.next = new ListNode(1);
    }
    return pHead.next;
};
```

## 3. [无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters)

```txt
遍历一轮，res保存遍历到的不重复的字符串，maxLen记录最大的长度

此方法只能求出最大的不重复子串的长度
时间复杂度：O(N)
```

```js
var lengthOfLongestSubstring = function(s) {
    let res = '';
    let maxLen = 0;
    let cur = 0;
    while (cur < s.length) {
        if (res.indexOf(s[cur]) === -1) {
            res += s[cur];
        } else {
            let index = res.indexOf(s[cur]);
            res = res.slice(index + 1) + s[cur]
        }
        maxLen = Math.max(maxLen, res.length);
        cur++;
    }
    return maxLen;
};
```

## 5. [最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring)

- 动态规划

```txt
dp[i][j] 表示字符串[i, j]范围内的字符是否是回文字符串

时间复杂度O(N^2)
空间复杂度O(N^2)
```

```js
/**
 * @param {string} s
 * @return {string}
 */
var longestPalindrome = function (s) {
    if (!s || !s.length) return '';
    let dp = [];
    let res = s[0];

    // 倒着遍历简化操作， 这么做的原因是dp[i][..]依赖于dp[i + 1][..]
    for (let i = s.length; i >= 0; i--) {
        dp[i] = [];
        for (let j = i; j < s.length; j++) {
            if (j - i === 0) dp[i][j] = true;
            else if (j - i === 1 && s[i] === s[j]) dp[i][j] = true;
            else if (s[i] === s[j] && dp[i + 1][j - 1]) {
                dp[i][j] = true;
            }

            if (dp[i][j] && j - i + 1 > res.length) {
                res = s.slice(i, j + 1);
            }
        }
    }
    return res;
};
```

- 双指针法

```txt
1、如果字符串长度小于2，直接返回原字符串
2、定义两个变量，一个start存储当前找到的最大回文字符串的起始位置，另一个manLength记录字符串的长度（终止位置就是start+maxLength）
3、创建一个expandAroundCenter函数，判断左边和右边是否越界，同时左边的字符是否等于右边的字符，
如果以上3个条件都满足，则判断是否需要更新回文字符串最长的长度及最大字符串的起始位置，然后将left--， right++，
继续判断，直到不满足三个条件之一
4、遍历字符串，每个位置调用expandAroundCenter两遍，第一遍检查i-1,i+1，第二遍检查i,i+1

时间复杂度O(N^2)
空间复杂度O(1)
```

```js
var longestPalindrome = function(s) {
    if (s.length < 2) {
        return s
    }
    let start = 0;
    let maxLength = 1;
    let expandAroundCenter = (left, right) => {
        while (left >= 0 && right < s.length && s[left] === s[right]) {
            if (right - left + 1 > maxLength) {
                start = left;
                maxLength = right - left + 1;
            }
            left--;
            right++;
        }
    }
    for (let i = 0; i <= s.length; i++) {
        expandAroundCenter(i - 1, i + 1);
        expandAroundCenter(i, i + 1);
    }
    return s.substring(start, start + maxLength);
};
```

## 6. [Z字形变换](https://leetcode-cn.com/problems/zigzag-conversion)

```txt
这个Z字形变换的话相当于是有numRows行数据，要将字符串s中的每个字母依次从上往下再从下往上添加到这个numRows行中，
我只需要用一个列表去存放这numRows行数据，初始化列表中每个元素为空字符串，用一个pos指针来对应列表中第几个元素，
然后用一个flag来标识我是 从左往右 还是 从右往左 向数组中元素添加字母，最终只需将这个数组拼接起来

举例：s="leetcode" numRows=3

arr = ['', '', '']

1. ['l','','']
2. ['l','e','']
3. ['l','e','e']
4. ['l','et','e']
5. ['lc','et','e']
6. ['lc','eto','e']
7. ['lc','eto','ed']
8. ['lc','etoe','ed']

answer = "lcetoeed"
```

代码：

```js
var convert = function(s, numRows) {
  if(numRows===1)return s;
  const arr = [];
  for(let i=0;i<numRows;i++){
    arr[i]=''
  }
  let pos = 0;
  let down = false;
  for(let item of s){
    arr[pos]+=item;
    if(pos===0||pos===numRows-1){
      down=!down
    }
    pos+=down?1:-1;
  }
  return arr.join('')
};
```

## 7. [整数反转](https://leetcode-cn.com/problems/reverse-integer)

```txt
原数x, 新数res。利用`int tmp = x % 10;` 。取个位，然后将其作为新数的最高位`res = res*10 + tmp;`，更新x：` x /= 10;`。重复上述操作，直到x = 0。此间不断判断是否溢出
```

## 9. [回文数](https://leetcode-cn.com/problems/palindrome-number)

```txt
进阶不将整数转换为字符串，思路：
1.x是负数肯定不是回文数
2.x是0-9的数肯定是回文数
3.x>9的时候，又分两种可能：
  （1）奇数个数，类似x=121，
  （2）偶数个数，类似x=1221
  这两种情况初始化一个reverse变量为0，每次循环reverse都等于自身*10加上x的个位数（reverse=reverse*10+x%10），x整除10（x/=10）,直到x的值比reverse小停止循环。
  只需判断一下reverse与x是否相等（偶数个数），reverse对10整除后是否与x相等（奇数个数）

例如 x=121（奇数个数）
  1、reverse=1, x=12
  2、reverse=12, x=1
  reverse/10 = x （是回文数）

例如 x=1221（偶数个数）
  1、reverse=1, x=122
  2、reverse=12, x=12
  reverse = x （是回文数）
```

代码：

```js
var isPalindrome = function(x) {
    if(x<0||x!==0&&x%10==0)return false;
    else if(x<=9)return true
    else{
        var reverse = 0;
        while(x>reverse){
            reverse=reverse*10+x%10;
            x=parseInt(x/10)
        }
        return reverse===x||parseInt(reverse/10)===x
    }  
};
```

## 11. [盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water)

```txt
用双指针法，left和right指针分别指向数组的头和尾，这个时候可以计算一下left和right对应区间可容纳的水:
res = (right-left) * Math.max(height[left],height[right])
当左右指针移动时，res变大只有一种情况，那就是left和right指针对应的数中小的那个数移动了之后变大了。
也就时长方形的宽度在减小，要想使面积变大，必须使得高度变大。
```

代码：

```js
var maxArea = function(height) {
  var left=0, right=height.length-1;
  var max = 0;
  while(left<right){
    max = Math.max(max, [right-left]*Math.min(height[left], height[right]));
    if(height[left]<height[right]){
      left++
    }else{
      right--
    }
  }
  return max
};
```

## 12. [整数转罗马数字](https://leetcode-cn.com/problems/integer-to-roman)

```txt
简单粗暴，罗列出个十百千位的所有可能性：
个位：['','I','II','III','IV','V','VI','VII','VIII','IX']
十位：['','X','XX','XXX','XL','L','LX','LXX','LXXX','XC']
百位：['','C','CC','CCC','CD','D','DC','DCC','DCCC','CM']
千位：['','M','MM','MMM']

然后根据给的num，拿到个十百千位的罗马数字拼接起来
```

```js
var intToRoman = function(num) {
  const qian = ['', 'M', 'MM', 'MMM'];
  const bai = ['','C','CC','CCC','CD','D','DC','DCC','DCCC','CM'];
  const shi = ['','X','XX','XXX','XL','L','LX','LXX','LXXX','XC'];
  const ge = ['','I','II','III','IV','V','VI','VII','VIII','IX']
  return (qian[parseInt(num/1000)]
    +bai[parseInt(num/100)%10]
    +shi[parseInt(num/10)%10]
    +ge[num%10])
};
```

## 13. [罗马数字转整数](https://leetcode-cn.com/problems/roman-to-integer)

将所有可能的情况保存在一个对象中：

```txt
map = {
  'I' : 1,
  'IV': 4,
  'V' : 5,
  'IX': 9,
  'X' : 10,
  'XL': 40,
  'L' : 50,
  'XC': 90,
  'C' : 100,
  'CD': 400,
  'D' : 500,
  'CM': 900,
  'M' : 1000,
};

然后对给定的罗马字符进行遍历，每次需要判断一下：
连续两个字符在对象是否存在，存在就用这连续两个字符的值；不存在就用当前遍历的字符的值
```

```js
var romanToInt = function(s) {
    var map = {
        'I': 1,
        'IV': 4,
        'V': 5,
        'IX': 9,
        'X': 10,
        'XL': 40,
        'L': 50,
        'XC': 90,
        'C': 100,
        'CD': 400,
        'D': 500,
        'CM': 900,
        'M': 1000
        };
    var i = 0;
    var ans = 0;
    while(i < s.length){
        let str = s.slice(i, i+2);
        if(map[str]){
           ans += map[str];
           i += 2;
        }else{
            ans += map[s[i]];
            i += 1;
        }
    }
    return ans;
};
```

## 14. [最长公共前缀](https://leetcode-cn.com/problems/longest-common-prefix)

```js
/**
 * @param {string[]} strs
 * @return {string}
 */
var longestCommonPrefix = function(strs) {
    if(!strs.length)return ''
    var ans = strs[0];
    for(let i=1; i<strs.length; i++){
        let j=0;
        for(;j<ans.length && j<strs[i].length;j++){
            if(ans[j] !== strs[i][j]){
                break
            }
        }
        ans = ans.slice(0, j);
    }
    return ans
};
```

```txt
先拿出第一个字符串first，再遍历剩余的字符串，每一次遍历：
对每一个字符串str判断的与first公共前缀的字符串，遍完将将first重新赋值为公共前缀，再
再遍历下一个字符串，最后得到的first就是所有字符串的公共前缀

举例： strs = ["flower","flow","flight"]

first = "flower"
遍历剩余的字符串：
    遍历第一次：
        str = "flow", 判断此时与first相同的前缀  first = "flow"
    遍历第二次：
        str = "flight"，判断此时与first相同的前缀  first = "fl"
遍历结束，公共前缀就是first
```

## 15. [三数之和](https://leetcode-cn.com/problems/3sum)

```js

var threeSum = function(nums) {
    var ans = [];
    nums.sort((a,b) => a-b);
    for(let i=0; i<nums.length-2; i++){
        if(nums[i]>0)break;
        if(nums[i]===nums[i-1])continue // 去重
        var L=i+1,R=nums.length-1;
        while(L<R){
            var sum=nums[i]+nums[L]+nums[R];
            if(sum===0){
                ans.push([nums[i],nums[L],nums[R]]);
                while(L<R&&nums[L]===nums[L+1]){L++} // 去重
                while(L<R&&nums[R]===nums[R-1]){R--} // 去重
                L++;
                R--;
            }else if(sum>0){
                R--;
            }else{
                L++;
            }
        }
    }
    return ans;
};
```

```txt
首先对数组进行排序，排序后固定一个数 nums[i]nums[i]，再使用左右指针指向 nums[i]nums[i]后面的两端，数字分别为 nums[L]nums[L] 和 nums[R]nums[R]，计算三个数的和 sumsum 判断是否满足为 00，满足则添加进结果集
如果 nums[i]nums[i]大于 00，则三数之和必然无法等于 00，结束循环
如果 nums[i]nums[i] == nums[i-1]nums[i−1]，则说明该数字重复，会导致结果重复，所以应该跳过
当 sumsum == 00 时，nums[L]nums[L] == nums[L+1]nums[L+1] 则会导致结果重复，应该跳过，L++L++
当 sumsum == 00 时，nums[R]nums[R] == nums[R-1]nums[R−1] 则会导致结果重复，应该跳过，R--R−−
时间复杂度：O(n^2)
```

## 16. [最接近的三数之和](https://leetcode-cn.com/problems/3sum-closest)

```txt
思路一：复杂度O(N^3)
三层循环，将三个数相加，和与target求差的绝对值最小的时候，返回这三个数的和

思路二：复杂度 O(N^2)
先对nums进行排序，然后对nums做一层遍历，当前遍历元素nums[i]，用两个指针L，R分别为 i+1 和 nums.length-1，求和 sum=nums[i]+nums[L]+nums[R]，初始化ans（到target距离最小的和）为前三位加起来的和，判断：
1. 若sum 到 target 的距离比 ans 到 target 的距离小，则更新ans为sum
2. 若sum < target, L++
3. 若sum > target, R--
4. 若sum = target, 返回sum
```

```js

var threeSumClosest = function(nums, target) {
  var res=nums[0]+nums[1]+nums[2], min=Infinity;
  nums.sort((a,b)=>a-b);
  for(let i=0;i<nums.length-2;i++){
    var L=i+1, R=nums.length-1;
    while(L<R){
      var sum = nums[i]+nums[L]+nums[R];
      if(Math.abs(sum-target) < Math.abs(res-target)){
        res = sum;
      } else if(sum < target){
        L++
      } else if(sum > target){
        R--
      } else if(sum === target){
        return sum
      }
    }
  }
  return res;
};
```

## 17. [电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number)

```txt
首先用一个对象保存所有可能的情况
遍历digits，拿到对应的字母
res为空数组的时候初始化第一个按键产生的字母
到了第二个以后的按键只用现有res中取到所有现有字母组合并和此按键的元素拼接字符串即可

举例：digits='23'
初始化res = []
遍历digits第一次：
  res = ['a', 'b', 'c']
遍历digits第二次：得到字母 'def'
  对 'def' 从第二个（索引为1）进行遍历，tmp = ['ae', 'af', 'be', 'bf', 'ce', 'cf']
  将res的每一项添加 'def' 的第一项，即 res = ['ad', 'bd', 'cd']
  然后将 tmp 的每一项添加到 res 中，得到最终的结果 ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"]
```

```js
var letterCombinations = function(digits) {
  const map = {
      2: "abc",
      3: "def",
      4: "ghi",
      5: "jkl",
      6: "mno",
      7: "pqrs",
      8: "tuv",
      9: "wxyz"
  };
  const res = [];
  for(let num of digits){
    let w = map[num];
    if(res.length!==0){
      let tmp = [];
      for(let i=0;i<res.length;i++){
        for(let j=1;j<w.length;j++){
          tmp.push(res[i]+w[j]);
        }
        res[i]+=w[0];
      }
      res.push(...tmp);
    }else{
      res.push(...w)
    }
  }
  return res;
};
```

## 19. [删除链表的倒数第N个节点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list)

```txt
首先先设置一个辅助头结点 post，让辅助头结点指向给定的 head 链表，然后用双指针 left 和 right ，初始都指向辅助头结点
先让 right 指针走n步，然后 right 和 left 指针同时走，当 right 指针走到最后的时候，这个时候的 left 指针的下一个结点就是我们要删除的。

时间复杂度：O(N)，N是链表的长度
空间复杂度：O(1)
```

```js
var removeNthFromEnd = function(head, n) {
    let post = new ListNode(-1);
    post.next = head;
    let left = post, right=post;
    for(let i=0; i<n; i++) {
        right = right.next
    }
    while(right && right.next) {
        left = left.next;
        right = right.next;
    }
    left.next = left.next.next;
    return post.next;
};
```

## 20. [有效的括号](https://leetcode-cn.com/problems/valid-parentheses)

```txt
字符串的长度为奇数肯定是false
对字符串遍历，碰到左括号 '[({' 就压入栈中，碰到右括号 '])}' ，将栈顶元素弹出，与当前遍历字符判断一下是不是一对括号，不是返回false
遍历结束后判断一下栈中是否还有元素，有则是false，没有则是true
```

```js
/**
 * @param {string} s
 * @return {boolean}
 */
var isValid = function(s) {
  if(s.length % 2 === 1) return false
  var stack = [];
  var map = {
    ")": "(",
    "}": "{",
    "]": "["
  };
  for(let i=0; i<s.length; i++) {
    var str = s[i];
    if(str==='('||str==='{'||str==="["){
      stack.push(str);
    } else {
      if (stack.pop() !== map[str]) {
        return false
      }
    }
  }
  if (stack.length !== 0) return false
  return true
};
```

## 21. [合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists)

```txt
创建一个辅助头节点head，用指针p指向head，
用两个指针p1 p2 分别指向l1 l2 ，当p1和p2都存在的时候，判断一下p1.val和p2.val的大小：
 p1.val < p2.val. => p.next = p1
 否则 p.next = p2
p1 p2只要有一个为空，就结束循环，看一下p1 p2谁还存在:
 p1存在：p.next = p1
 p2存在：p.next = p2
最后返回head.next，也就是辅助头节点的下一个节点
```

```js
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var mergeTwoLists = function(l1, l2) {
    var p1 = l1, p2 = l2;
    var head = new ListNode(-1); // 辅助头节点
    var p = head;
    while(p1 && p2) {
        var n1 = p1.val;
        var n2 = p2.val;
        if(n1 < n2) {
            p.next = p1;
            p1 = p1.next;
        }else {
            p.next = p2;
            p2 = p2.next;
        }
        p = p.next
    }
    if(p1) {p.next = p1}
    if(p2) {p.next = p2}
    return head.next
};
```

## 24. [两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs)

```txt
构建一个哨兵节点0，例如：1->2->3->4
则：0->1->2->3->4
让p指向0，pre指向1，cur指向2
对其做指针指向操作：p指向cur，（pre.next是cur的next），cur指向pre
对链表做一次遍历即可。
时间复杂度O(N),空间复杂度O(1)
```

```js
var swapPairs = function(head) {
    let node = new ListNode(-1);
    node.next = head;
    let p = node;
    while(p && p.next && p.next.next) {
        let pre = p.next;
        let cur = pre.next;
        p.next = cur;
        pre.next = cur.next;
        cur.next = pre;
        p = pre;
    }
    return node.next;
};
```

## 26. [删除排序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array)

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var removeDuplicates = function(nums) {
   let index = 1;
  for(let i=1; i< nums.length ; i++) {
    if(nums[i] !== nums[i-1]){
      nums[i]=n;
        index+=1;  
    }
  }
  return index;
};
```

## 27. [移除元素](https://leetcode-cn.com/problems/remove-element)

```txt
遍历数组nums，遍历指针为i，总长度为ans
在遍历过程中如果出现数字与需要移除的值不相同时，则i自增1，继续下一次遍历
如果相同的时候，则将nums[i]用nums[ans-1]覆盖，即当前数字和数组最后一个数字进行交换，交换后就少了一个元素，故而ans自减1
```

```js

// 思路2
var removeElement = function(nums, val) {
  var ans = nums.length;
  for(let i=0;i<ans;){
    if(val === nums[i]){
      nums[i] = nums[ans-1]
      ans--;
    }else{
      i++;
    }
  }
  return ans
};
```

## 31. [下一个排列](https://leetcode-cn.com/problems/next-permutation)

```txt
1.从数组的末尾寻找第一对升序排列的值i,j
2.在j后面的数组现在肯定都是降序排列的，包括j自己
3.此时，在[j, nums.length - 1]的区间从后往前寻找第一个
  大于nums[i]的位置k，注意这里一定是大于，等于不可以
4.交换nums[i] 和 nums[k] 处的值
5.此时，区间[j, nums.length]区间内肯定是降序排列的
  所以此时需要将此区间内的数组改成降序排列才能得到更小的值
6.因为[j, nums.length]区间内的数组是降序，所以
  收尾交换数据即可完成升序排列

时间复杂度：O(N)
空间复杂度：O(1)
```

```js
var nextPermutation = function(nums) {
  if (nums.length < 2) return nums;
  let len = nums.length;
  let i = len - 2;
  let j = len - 1;
  let k = len - 1;
  // 寻找从数组末尾开始的第一个升序的i,j
  while (i >= 0 && nums[i] >= nums[j]) {
    i--;
    j--;
  }
  // 说明数组是降序排列的
  if (i < 0) return nums.sort((a, b) => a - b);
  // 从数组末尾寻找第一个比nums[i]大的值
  // 注意边界和相等问题
  while (k > i && nums[i] >= nums[k]) {
    k--;
  }
  // 交换i，k处的值
  [nums[i], nums[k]] = [nums[k], nums[i]]
  // j后的数据现在肯定是降序排列,转化为升序排列
  // 收尾依次交换位置即可
  while (len > j) {
    [nums[j], nums[len - 1]] = [nums[len - 1], nums[j]]
    len--;
    j++;
  }
  return nums;
}
```

## 33. [搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array)

```txt
二分法：
L指向数组第一个数，R指向数组最后一个数，mid为L和R的中间数，当L<=R的时候，判断：
  1）若中位数刚好等于target，则返回这个mid
  2）若中位数比第一个数大，说明[L, mid]这个区间的数是有序的，继续判断：
    若target在[L, mid]之间，则另R=mid-1
    否则另L=mid+1
  3）若中位数比最后一个数小，说明[mid, R]这个区间的数是有序的，继续判断：
    若target在[mid, R]之间，则另L=mid+1
    否则另R=mid-1
循环结束都不满足条件就返回-1
```

```js
var search = function(nums, target) {
    let L = 0, R = nums.length - 1;
    while (L <= R) {
        let mid = (L + R) >> 1;
        if (target === nums[mid]) {
            return mid;
        }
        if (nums[mid] >= nums[L]) { // mid左边是有序的数组
            if(target >= nums[L] && target <= nums[mid]) { // target在 [L, mid]之间，且有序
                R = mid - 1;
            } else { // target不在 [L, mid]之间
                L = mid + 1;
            }
        }else { // mid右边是有序的数组
            if(target >= nums[mid] && target <= nums[R]) { // target在[mid, R]之间，且有序
                L = mid + 1;
            } else { // target不在 (mid, R]之间
                R = mid - 1;
            }
        }
    }
    return -1
};
```

## 34. [在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

```txt
方法1：
    二分查找法，题目就是查找 第一个大于等于target的位置 和 第一个大于target的位置减一

    时间复杂度：O(logN)
    空间复杂度：O(1)
```

```js
// 方法1
var searchRange = function (nums, target) {
    let binarySearch = (nums, target, flag) => {
        let left = 0, right = nums.length - 1, ans = nums.length;
        while (left <= right) {
            let mid = (left + right) >> 1;
            if (nums[mid] > target || (flag && nums[mid] >= target)) {
                right = mid - 1;
                ans = mid;
            } else {
                left = mid + 1;
            }
        }
        return ans
    }

    let leftIdx = binarySearch(nums, target, true); // 找到第一个大于等于target的位置
    let rightIdx = binarySearch(nums, target, false) - 1; // 找到第一个大于target的位置，然后减一
    if (leftIdx <= rightIdx) {
        return [leftIdx, rightIdx]
    } else return [-1, -1]
};


```

## 35. [搜索插入位置](https://leetcode-cn.com/problems/search-insert-position)

```txt
二分法：
用两个指针left right分别记录左右下标，每次取得左右下标的中位数的下标mid，判断一下中位数与target的大小：
  若比target小，说明target在mid右边，让left=mid+1;
  否则的话在mid左边（可能就是mid这个数），让right=mid;
```

```js

var searchInsert = function(nums, target) {
    var left=0, right=nums.length-1;
    if(target > nums[right]) {
        return right+1;
    }
    while(left < right) {
        var mid = (left + right) >> 1;
        if(target > nums[mid]) {
            left = mid + 1;
        }else {
            right = mid;
        }
    }
    return left;
};
```

## 39. [组合总和](https://leetcode-cn.com/problems/combination-sum)

- 回溯

```js
var combinationSum = function(candidates, target) {
    let ans = [];
    let dfs = (target, combine, id) => {
        if (id === candidates.length) return;
        if (target === 0) {
            ans.push(combine.slice());
            return;
        }
        if (target - candidates[id] >= 0) {
            dfs(target - candidates[id], [...combine, candidates[id]], id);
        }
        dfs(target, combine, id+1);
    }
    dfs(target, [], 0)
    return ans
};
```

## 40. [组合总和Ⅱ](https://leetcode-cn.com/problems/combination-sum-ii)

- 回溯+减枝

```js
var combinationSum2 = function (candidates, target) {
    let ans = [];
    candidates.sort((a, b) => a - b);
    let backtrack = (combine, target, id) => {
        if (target === 0) {
            ans.push(combine.slice())
            return
        }
        for (let i = id; i < candidates.length; i++) {
            if (target < candidates[i]) return;
            if (i > id && candidates[i - 1] === candidates[i]) continue;
            combine.push(candidates[i]);
            backtrack(combine.slice(), target - candidates[i], i + 1);
            combine.pop();
        }
    }
    backtrack([], target, 0);
    return ans
};
```

## 48. [旋转图像](https://leetcode-cn.com/problems/rotate-image/)

```txt
题目要求原地修改矩阵，先说明一下如果不原地修改数组的方法：
matrix 中 [row, col] 的位置顺时针旋转90°后变为 [col, n - 1 - row]，那只需要一个辅助矩阵即可求出

只在原地修改的话，矩阵可以这样变换：先水平翻转一次，再主对角线翻转一次，即可得到想要的矩阵，举个例子如下：

| 1 2 3 |                   | 7 8 9 |                 | 7 4 1 |
| 4 5 6 |   ==========>     | 4 5 6 |    ==========>  | 8 5 2 |
| 7 8 9 |                   | 1 2 3 |                 | 9 6 3 |

时间复杂度：O(n^2)
空间复杂度：O(1)
```

```js
var rotate = function (matrix) {
    const n = matrix.length;
    // 水平翻转
    for (let i = 0; i < n >> 1; i++) { // 注意这里只需要交换矩阵的上半部分就够了
        for (let j = 0; j < n; j++) {
            [matrix[i][j], matrix[n - 1 - i][j]] = [matrix[n - 1 - i][j], matrix[i][j]]
        }
    }
    // 主对角线翻转
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < i; j++) { // 注意这里交换右上部分就够了
            [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]]
        }
    }
    return matrix
};
```

## 49. [字母异位词分组](https://leetcode-cn.com/problems/group-anagrams/)

```txt
将每个字符按照 ASCII 码排序后作为对象的键，值为一个数组，爸与键互为字母异位词的添加到这个数组中

时间复杂度：O(n*klogk)，n 是 strs 的长度，k 是 strs 中最长字符的长度73
空间复杂度：O(nk)
```

```js
var groupAnagrams = function(strs) {
    let map = {};
    strs.forEach(str => {
        let tmp = str.split('').sort();
        if (map[tmp] !== undefined) {
            map[tmp].push(str)
        } else {
            map[tmp] = [str]
        }
    })
    return Object.values(map)
};
```

## 53. [最大子序和](https://leetcode-cn.com/problems/maximum-subarray)

```txt
方法1：遍历一次，从第一个大于0的数开始，求和并且每一步更新和的最大值，求和过程中如果小于0，则抛弃这个，从后续大于0的数继续。

方法2：动态规划，dp[i] 定义为以 nums[i] 结尾的最大子数组的和，状态转移方程：
        dp[i] = max{ dp[i-1] + nums[i], nums[i] }     表示要么自成一派，要么和前面的子数组合并
连续子数组的最大和一定是 dp 数组的最大值
```

- 方法1

```js
var maxSubArray = function(nums) {
    var maxSum = nums[0];
    var num = nums[0];
    for(let i=1; i<nums.length; i++) {
        if (num < 0) {
            num = nums[i];
        }else {
            num += nums[i];
        }
        maxSum = Math.max(maxSum, num);
    }
    return maxSum;
};
```

- 方法2

```js
var maxSubArray = function (nums) {
    let len = nums.length;
    let dp = [];
    dp[0] = nums[0];
    for (let i = 1; i < len; i++) {
        dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]);
    }
    return Math.max(...dp);
};
```

## 61. [旋转链表](https://leetcode-cn.com/problems/rotate-list)

```txt
思路1:
双指针法：右指针先走k步，然后左右指针一起走，在右指针走到最后的时候左指针的位置就是要动的地方。

思路2:
求出链表的size，然后可以求出链表中要动的地方。
```

```js
// 思路1
var rotateRight = function(head, k) {
    if(!head) return null;
    let left = head;
    let right = head;
    for(let i = 0; i < k; i++) {
        right = right.next;
        if(!right){
            right = head;
        }
    }
    while(right.next) {
        left=left.next;
        right=right.next;
    }
    if(!left.next) return head;
    let node = left.next;
    left.next=null;
    let p = node;
    while(p.next) {
        p = p.next;
    }
    p.next = head;
    return node;
};

// 思路2
var rotateRight = function(head, k) {
    if(!head || !head.next) return head;
    let left = head;
    let right = head;
    let size = 1;
    while(right.next) {
        size++;
        right = right.next;
    }
    k = size - k % size;
    while(k > 1) {
        left = left.next;
        k--;
    }
    if(!left.next) return head;
    let node = left.next;
    left.next = null;
    let p = node;
    while(p.next) {
        p = p.next;
    }
    p.next = head;
    return node;
};
```

## 62. [不同路径](https://leetcode-cn.com/problems/unique-paths/)

```txt
动态规划

    dp[i][j]定义为处于(i, j)位置有多少种可能的路径到达

    dp[i][j] = dp[i-1][j] + dp[i][j-1]   解释：(i, j) 的位置只可能是从上面 (i, j-1) 和 左边 (i-1, j) 到达

时间复杂度：O(mn)
空间复杂度：O(mn)
```

```js
var uniquePaths = function (m, n) {
    let dp = Array(m).fill(0).map(e => Array(n).fill(0));
    for (let i = 0; i < m; i++) {
        dp[i][0] = 1;
    }
    for (let j = 0; j < n; j++) {
        dp[0][j] = 1;
    }
    for (let i = 1; i < m; i++) {
        for (let j = 1; j < n; j++) {
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
        }
    }
    return dp[m-1][n-1]
};
```

## 70. [爬楼梯](https://leetcode-cn.com/problems/climbing-stairs)

```txt
典型动态规划
dp[i] = dp[i-1] + dp[i-2]

时间复杂度：O(N)
空间复杂度：O(1)
```

```js
var climbStairs = function (n) {
    let a = 0, b = 0, res = 1;
    for (let i = 1; i <= n; i++) {
        a = b;
        b = res;
        res = a + b;
    }
    return res;
};
```

## 75. [颜色分类](https://leetcode-cn.com/problems/sort-colors)

- 单指针

```txt
遍历一次将所有的 0 换到最前面，将所有的 2换到最后

时间复杂度：O(N)
空间复杂度：O(1)
```

```python
class Solution:
    def sortColors(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        n= len(nums)-1
        i=0  # 计数1和0
        j=0  # 记数0
        while i<=n:
            if nums[i]==0:
                nums[i],nums[j]=nums[j],nums[i]
                i+=1
                j+=1
            elif nums[i]==1:
                i+=1
            else:
                nums[i],nums[n]=nums[n],nums[i]
                n-=1                
```

- 双指针

```txt
这里用两个指针 p 和 q ，遍历数组：
当为 1 的时候就与 q 指针对应的数交换并把 q 指针后移一位，
当为 0 的时候就与 p 指针对应的数交换，这里首先要判断一下 p 指针是不是在 q 指针的前面，如果是，需要把当前的数再与 q 指针交换一下，然后再把两个都后移一位
因为当遍历到 0 的时候，可能这个时候p 指针对应的数可能是 1，然后与 p 指针交换之后当前遍历的位置就变成了 1，如果这个时候循环结束的话是有问题的，因为 1 是要放在中间的

时间复杂度：O(N)
空间复杂度：O(1)
```

```js
var sortColors = function (nums) {
    let n = nums.length;
    let [p, q] = [0, 0];
    for(let i=0; i<n; i++) {
        if (nums[i] === 0) {
            [nums[i], nums[p]] = [nums[p], nums[i]];
            if (p < q) {
                [nums[i], nums[q]] = [nums[q], nums[i]];
            }
            p++;
            q++;
        } else if (nums[i] === 1) {
            [nums[i], nums[q]] = [nums[q], nums[i]];
            q++;
        }
    }
    return nums;
};
```

## 78. [子集](https://leetcode-cn.com/problems/subsets)

- 方法一：迭代法实现子集枚举

```txt
[1,3,5]的子集，每个数字有两种可能，选或不选，我们可以用二进制数 1 和 0 来表示选或不选
所以[1,3,5]的子集就可以表示成 000 - 111 之间所有的可能，000表示都不选，即空集[]，111表示都选，即[1,3,5]
三位数字每一位表示数组里对应位的元素选还是不选

时间复杂度：O(N*2^N)
空间复杂度：O(N)
```

```js
var subsets = function (nums) {
    let res = [];
    const n = nums.length;
    for (let i = 0; i < (1 << n); i++) { // 1 << n 表示的意思就是 2 ^ n
        let tmp = [];
        for (let j = 0; j < n; j++) { // 遍历n个二进制数字，找到为1的对应的数组中的元素，将其添加到临时数组中
            if (i & (1 << j)) {
                tmp.push(nums[j]);
            }
        }
        res.push(tmp)
    }
    return res
};
```

- 方法二：递归法实现子集枚举

```txt
dfs深度优先遍历

时间复杂度：O(N*2^N)
空间复杂度：O(N)
```

```js
var subsets = function (nums) {
    const res = [];
    const tmp = [];
    const n = nums.length;
    let dfs = cur => {
        if (cur === n) {
            res.push(tmp.slice());
            return;
        }
        tmp.push(nums[cur]);
        dfs(cur + 1);
        tmp.pop(nums[cur]);
        dfs(cur + 1);
    }
    dfs(0);
    return res;
};
```

## 82. 删除排序链表中的重复元素 II

```txt
快慢指针
  快指针：跳过重复数，记录下一个前面没有重复数的节点位置
  慢指针：标记重复数字出现起点，根据链表特性，负责与下一个快指针相连
```

```js
var deleteDuplicates = function(head) {
    let node = new ListNode(-1); // 哨兵节点
    node.next = head;
    let fast = node.next;
    let slow = node;
    while(fast) {
        if(fast.next && fast.next.val === fast.val) {
            let sameVal = fast.val; // 先把相等的值保存下来
            while(fast && fast.val === sameVal) {
                fast = fast.next;
            }
            slow.next = fast;
        }else{
            slow.next = fast;
            slow = fast;
            fast = fast.next;
        }
    }
    return node.next;
};
```

## 83. [删除排序链表中的重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list)

```txt
直接法，简单
```

```js
var deleteDuplicates = function(head) {
    let p = head;
    while(p && p.next) {
        if(p.val === p.next.val){
            p.next = p.next.next;
        }else{
            p = p.next;
        }
    }
    return head;
};
```

## 86. [分隔链表](https://leetcode-cn.com/problems/partition-list/)

```txt
模拟法：
    模拟两个链表，一个表示比 x 小的，一个表示比 x 大的

时间复杂度：O(n)，其中 n 是原链表的长度
空间复杂度：O(1)
```

```js
var partition = function(head, x) {
    let small = new ListNode(0);
    let large = new ListNode(0);
    let smallHead = small, largeHead = large;
    while (head) {
        if (head.val < x) {
            small.next = head;
            small = small.next
        } else {
            large.next = head;
            large = large.next
        }
        head = head.next;
    }
    large.next = null
    small.next = largeHead.next
    return smallHead.next
};
```

## 94. [二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal)

- 递归

```js
var inorderTraversal = function(root) {
    let res = [];
    let mid = root => {
        if (!root) return null;
        mid(root.left);
        res.push(root.val);
        mid(root.right);
    }
    mid(root)
    return res;
};
```

- 迭代算法（借助栈）

```js
var inorderTraversal = function (root) {
    let nodes = [];
    let res = [];
    while (root || nodes.length) {
        if (root) {
            nodes.push(root);
            root = root.left;
        } else {
            let node = nodes.pop();
            res.push(node.val);
            root = node.right;
        }
    }
    return res
};
```

## 103. [二叉树的锯齿形层序遍历](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)

```txt
层序遍历的变种，只要加一个flag标志位就好了

时间复杂度：O(N)，其中 N 为二叉树的节点数。每个节点会且仅会被遍历一次。
空间复杂度：O(N)，我们需要维护一个栈，空间复杂度为O(N)
```

```js
var zigzagLevelOrder = function(root) {
    if (!root) return []
    let stack = [root];
    let res = [];
    let flag = true;
    while (stack.length) {
        const len = stack.length;
        const tmp = [];
        for (let i=0; i<len;i++) {
            const node = stack.shift(); // 栈底元素
            node.left && stack.push(node.left)
            node.right && stack.push(node.right)
            flag ? tmp.push(node.val) : tmp.unshift(node.val)
        }
        res.push(tmp)
        flag = !flag
    }
    return res
};
```

## 107. [二叉树的层次遍历 II](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii)

> 借助栈的结构，依次把每层的结点放入栈中，再弹出

```js
var levelOrderBottom = function(root) {
  if (!root) return []; // 注意加上root不存在的情况
  let res = [];
  let nodes = [];
  nodes.push(root);
  while(nodes.length) {
    const len = nodes.length;
    let tmp = [];
    for(let i =0 ;i<len;i++) {
      let node = nodes.shift();
      tmp.push(node.val);
      node.left && nodes.push(node.left);
      node.right && nodes.push(node.right);
    }
    res.unshift(tmp);
  }
  return res;
};
```

## 112. [路径总和](https://leetcode-cn.com/problems/path-sum)

```txt
递归
  1. 转为判断，左、右子树能否找出满足和为 sum - 父节点值 的路径
  2. 当遍历到叶子节点时，因为已经没有子节点了，如果 sum 等于当前节点的值，就返回 true
```

```js
var hasPathSum = function(root, sum) {
  // 根节点为空
  if (root === null) return false;
  
  // 叶节点 同时 sum 参数等于叶节点值
  if (root.left === null && root.right === null) return root.val === sum;

  // 总和减去当前值，并递归
  sum = sum - root.val
  return hasPathSum(root.left, sum) || hasPathSum(root.right, sum);
};
```

## 116. [填充每个节点的下一个右侧节点指针](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)

- 层序遍历

```txt
层序遍历，然后每一层遍历的时候，让前一个指向后一个

时间复杂度：O(N)
空间复杂度：O(N)
```

```js
var connect = function(root) {
    if (!root) return null;
    let stack = [root];
    while(stack.length) {
        let len = stack.length;
        let pre = -1;
        for(let i=0; i<len; i++) {
            let node = stack.shift();
            node.left && stack.push(node.left)
            node.right && stack.push(node.right)
            if (pre !== -1) {
                pre.next = node;
                pre = node;
            } else {
                pre = node;
            }
        }
    }
    return root
};
```

- 使用已建立的 next 指针

```txt
完美二叉树只有两种情况：
（1）某节点的左子节点 -> 某节点的右子节点
（2）某节点的右子节点 -> 某节点 next 指针对应节点的左子节点

时间复杂度：O(N)
空间复杂度：O(1)
```

```js
var connect = function(root) {
    if (!root) return null;
    let head = root;
    while(head.left) {
        let node = head;
        while(node) {
            // node的左子节点 -> node的右子节点
            node.left.next = node.right;

            // node的右子节点 -> node.next的左子节点
            if (node.next) {
                node.right.next = node.next.left;
            }

            node = node.next;
        }
        head = head.left
    }
    return root
}
```

## 117. [填充每个节点的下一个右侧节点指针 II](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii)

```txt
层序遍历，然后每一层遍历的时候，让前一个指向后一个
```

```js
var connect = function (root) {
    if (!root) return null
    let queue = [root]
    while (queue.length) {
        const len = queue.length
        let last = null
        for (let i = 0; i < len; i++) {
            let node = queue.shift()
            node.left && queue.push(node.left)
            node.right && queue.push(node.right)
            if (i !== 0) {
                last.next = node;
            }
            last = node;
        }
    }
    return root
};
```

## 118. [杨辉三角](https://leetcode-cn.com/problems/pascals-triangle/)

```txt
逐行遍历设置就行了

时间复杂度：O(numRows^2)
空间复杂度：O(1)，不考虑返回值的空间占用。
```

```js
var generate = function (numRows) {
    let ans = [];
    for (let i = 1; i <= numRows; i++) {
        let tmp = Array(i).fill(1);
        for (let j = 1; j < i - 1; j++) {
            tmp[j] = ans[i - 2][j - 1] + ans[i - 2][j]
        }
        ans[i - 1] = tmp;
    }
    return ans
};
```

## 121. [买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock)

- 动态规划

```txt
dp[i]表示前i个中股票利润最大值
转移方程：
dp[i] = max{ dp[i-1], prices[i] - minprice }
```

```js
var maxProfit = function (prices) {
    let len = prices.length;
    if (len < 1) return 0;
    let dp = Array(len).fill(0);
    let minprice = prices[0];
    for (let i = 1; i < len; i++) {
        minprice = Math.min(minprice, prices[i]);
        dp[i] = Math.max(dp[i - 1], prices[i] - minprice);
    }
    return dp[len - 1]
};

// 改进 直接用一个max来保存这个最大利润
var maxProfit = function (prices) {
    let len = prices.length;
    let max = 0;
    let minprice = prices[0];
    for (let i = 1; i < len; i++) {
        minprice = Math.min(minprice, prices[i]);
        max = Math.max(max, prices[i] - minprice);
    }
    return max
};
```



## 122. [买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii)

```txt
用一个二维数组的动态方程
dp[i][0] 表示第i天 卖出 的最大利润
dp[i][1] 表示第i天 买入 的最大利润

状态转移方程：
dp[i][0] = max{ dp[i-1][0], dp[i-1][1]+prices[i] } 第i天卖出的最大利润等于第i-1天卖出的最大利润 或者 第i-1天买入的最大利润加上第i天的股价 两者的最大值
dp[i][1] = max{ dp[i-1][1], dp[i-1][0]-prices[i] } 第i天买入的最大利润等于第i-1天买入的最大利润 或者 第i-1天卖出的最大利润减去第i天的股价 两者的最大值

```

```js
var maxProfit = function(prices) {
    let len = prices.length;
    let dp = Array(len).fill(0).map(e => Array(2).fill(0));
    dp[0][0] = 0;
    dp[0][1] = -prices[0];
    for(let i=1; i<len; i++) {
        dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1]+prices[i]);
        dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0]-prices[i]);
    }
    return Math.max(dp[len-1][0], dp[len-1][1])
};
```

## 123. [买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)

动态规划

在任意一天结束后，我们会处于五种状态中的一种：

- 未进行任何操作
- 只进行了一次买操作
- 只进行一次买操作和一次卖操作，即完成了一笔交易
- 在完成了一笔交易的前提下，进行了第二次买操作
- 完成了两笔交易

由于第一个状态的利润显然为 0，因此我们可以不用将其记录。对于剩下的四个状态，我们分别将它们的最大利润记为 $buy_1$, $sell_1$, $buy_2$, $sell_2$

状态转移，知道第 `i-1` 天结束后的这四个状态，第 `i` 天的状态：

- 对于 $buy_1$

在第 `i` 天可以不进行任何操作，保持不变，也可以在未进行任何操作的前提下以 `prices[i]` 的价格买入股票，转移方程为：
$$buy_1(i) = max\{buy_1(i-1), -prices[i]\}$$
其中，$buy_1(i)$ 表示 `i` 天的状态，$buy_1(i-1)$ 表示 `i-1` 天的状态，下面也是类似。

- 对于 $sell_1$

在第 `i` 天我们可以不进行任何操作，保持不变，也可以在只进行过一次买操作的前提下以 `prices[i]` 的价格卖出股票，转移方程为：
$$sell_1(i) = max\{sell_1(i-1), buy_1(i)+prices[i]\}$$

- 对于 $buy_2$

同理转移方程为：
$$buy_2(i) = max\{buy_2(i-1), sell_1(i)-prices[i]\}$$

- 对于 $sell_2$

同理转移方程为：
$$sell_2(i) = max\{sell_2(i-1), buy_2(i)+prices[i]\}$$

理论上，我们需要维护四个数组  $buy_1[i]$ , $sell_1[i]$ , $buy_2[i]$ , $sell_2[i]$ ，但是因为每个状态只与前一天的状态有关，因而我们可以进一步降低空间复杂度，我们只需维护四个变量：$buy_1$ , $sell_1$ , $buy_2$ , $sell_2$，然后不断的更新这四个变量即可。

- 总的状态转移方程为：

$$
\begin{cases}
    buy_1 = max\{buy_1, -prices[i]\}\\\\
    sell_1 = max\{sell_1, buy_1+prices[i]\}\\\\
    buy_2 = max\{buy_2, sell_1-prices[i]\}\\\\
    sell_2 = max\{sell_2, buy_2+prices[i]\}
\end{cases}
$$

- 时间复杂度：O($n$)，其中 n 是数组 prices 的长度。
- 空间复杂度：O(1)。

代码如下：

```js
var maxProfit = function (prices) {
    const n = prices.length;
    let buy1 = -prices[0], buy2 = -prices[0], sell1 = 0, sell2 = 0;
    for (let i = 0; i < n; i++) {
        buy1 = Math.max(buy1, -prices[i])
        sell1 = Math.max(sell1, buy1 + prices[i])
        buy2 = Math.max(buy2, sell1 - prices[i])
        sell2 = Math.max(sell2, buy2 + prices[i])
    }
    return sell2;
};
```

## 125. [验证回文串](https://leetcode-cn.com/problems/valid-palindrome)

```txt
思路1:
用正则将字符串中所有的非数字字母字符替换成空字符，然后将新的字符全部变成小写，字符翻转判断是否相等。

思路2:
用正则将字符串中所有的非数字字母字符替换成空字符，然后将新的字符全部变成小写，然后用双指针法判断是否是回文字符。
```

```js
// 思路1:
var isPalindrome = function(s) {
    s = s.replace(/\W/g, '').toLowerCase();
    return s === s.split('').reverse().join('');
};


// 思路2:
var isPalindrome = function(s) {
    let str = s.replace(/[^0-9a-zA-Z]/g, '').toLowerCase();
    var left = 0, right = str.length-1;
    while(left < right) {
        if(str[left] !== str[right]) {
            return false;
        }
        left++;
        right--;
    }
    return true;
};
```

## 129. [求根到叶子节点数字之和](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/)

```txt
深度优先遍历
如图 分成子问题
           4                            dfs(4, 0)=1026
         /   \                        /             \
        9     0             dfs(9, 4)=986          dfs(0, 4)=40
       / \                   /      \
      5   1        dfs(5, 49)=495   dfs(1, 49)=491

时间复杂度：O(N)
空间复杂度：O(N)
```

```js
var sumNumbers = function(root) {
    let dfs = (root, preSum) => {
        if (!root) return 0;
        const sum = preSum * 10 + root.val;
        if (!root.left && !root.right) {
            return sum
        } else {
            return dfs(root.left, sum) + dfs(root.right, sum)
        }
    }
    return dfs(root, 0)
};
```

## 134. [加油站](https://leetcode-cn.com/problems/gas-station/)

```txt
理解意思 一次遍历即可

时间复杂度：O(N)
空间复杂度：O(1)

可以继续降低时间复杂度，我们首先检查第 0 个加油站，并试图找到第一个无法到达的加油站 x；如果能找到，下一次就从加油站 x+1 开始检查。最终，我们只遍历了原数组一次。
```

```js
var canCompleteCircuit = function (gas, cost) {
    const len = gas.length;
    // helper 函数用来判断从第 i 个加油站出发能否绕环路一周
    let helper = (i) => {
        let index = i;
        let count = gas[i] - cost[i];
        for (let k = 0; k < len; k++) {
            if (count < 0) return false
            index++
            if (index === len) {
                index = 0;
            }
            count = count + gas[index] - cost[index];
        }
        return true;
    }
    for (let i = 0; i < len; i++) {
        if (helper(i) === true) return i;
    }
    return -1
};
```

## 135. [分发糖果](https://leetcode-cn.com/problems/candy/)

```txt
我们可以将「相邻的孩子中，评分高的孩子必须获得更多的糖果」这句话拆分为两个规则，分别处理。
    左规则：当 ratings[i - 1] < ratings[i] 时，i 号学生的糖果数量将比 i - 1 号孩子的糖果数量多。
    右规则：当 ratings[i]>ratings[i+1] 时，i 号学生的糖果数量将比 i + 1 号孩子的糖果数量多。
我们遍历该数组两次，处理出每一个学生分别满足左规则或右规则时，最少需要被分得的糖果数量。每个人最终分得的糖果数量即为这两个数量的最大值。

时间复杂度：O(n)
空间复杂度：O(n)
```

```js
var candy = function (ratings) {
    const n = ratings.length;
    const left = Array(n).fill(0);
    for (let i = 0; i < n; i++) {
        if (i > 0 && ratings[i] > ratings[i - 1]) {
            left[i] = left[i - 1] + 1
        } else {
            left[i] = 1;
        }
    }
    let right = 0,
        ret = 0;
    for (let i = n - 1; i >= 0; i--) {
        if (i < n - 1 && ratings[i] > ratings[i + 1]) {
            right += 1
        } else {
            right = 1
        }
        ret += Math.max(left[i], right)
    }
    return ret
};
```

## 141. [环形链表](https://leetcode-cn.com/problems/linked-list-cycle)

```txt
思路1:
用一个列表去存储每次遍历的节点，只需要在每次遍历的时候判断一下当前节点是否已经存在即可
时间复杂度：O(N)
空间复杂度：O(N)

思路2:
快慢指针，只要链表存在环，那么快慢指针总会相遇。
时间复杂度：O(N)
空间复杂度：O(1)
```

```js
// 思路1
var hasCycle = function(head) {
    let p = head;
    let nodes = [];
    while(p) {
        if(nodes.indexOf(p) !== -1){
            return true;
        }
        nodes.push(p)
        p = p.next;
    }
    return false;
};

// 思路2
var hasCycle = function(head) {
    if(!head || !head.next) return false
    let slow = head;
    let fast = head.next;
    while(slow !== fast) {
        slow = slow.next;
        if(fast && fast.next) {
            fast = fast.next.next;
        }else{
            return false
        }
    }
    return true;
};
```

## 142. [环形链表Ⅱ](https://leetcode-cn.com/problems/linked-list-cycle-ii)

```txt
快慢指针先找到两个指针相遇的地方，然后在让一个指针ptr指向head，ptr和slow（相遇的点）同时出发，会在环的入口处相遇。
```

```js
var detectCycle = function(head) {
    let slow = head, fast = head;
    if (!head || !head.next) return null;
    while(fast && fast.next) {
        fast = fast.next.next;
        slow = slow.next;
        if (slow === fast) break;
    }
    if(slow !== fast) return null;
    while(head !== slow) {
        head = head.next;
        slow = slow.next;
    }
    return head;
};
```

## 143. [重排链表](https://leetcode-cn.com/problems/reorder-list/)

```txt
将链表每个节点存放数组中，再双指针遍历数组

时间复杂度：O(N)，N为链表的长度
空间复杂度：O(N)
```

```js
var reorderList = function(head) {
    let nodes = [];
    while (head) {
        nodes.push(head);
        head = head.next;
    }
    let phead = new ListNode(-1);
    let res = phead;
    let [l, r] = [0, nodes.length - 1];
    while(l < r) {
        phead.next = nodes[l];
        phead.next.next = nodes[r];
        l++;
        r--;
        phead = phead.next.next;
    }
    if (l===r) {
        phead.next = nodes[l];
        phead.next.next = null;
    } else {
        phead.next = null;
    }
    return res.next;
};
```

## 144. [二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

```txt
递归的简单，非递归的方法借助栈
时间复杂度：O(n)，其中 n 是二叉树的节点数。每一个节点恰好被遍历一次。
空间复杂度：O(n)，为迭代过程中显式栈的开销，平均情况下为 O(logn)，最坏情况下树呈现链状，为 O(n)
```

```js
var preorderTraversal = function(root) {
    if (!root) return [];
    let stack = [root];
    let vals = [];
    while(stack.length) {
        let node = stack.pop();
        vals.push(node.val);
        node.right && stack.push(node.right)
        node.left && stack.push(node.left)
    }
    return vals;
};
```

## 145. [二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal)

- 递归

```js
var postorderTraversal = function(root) {
    let res = [];
    let postMid = root => {
        if (!root) return null;
        postMid(root.left)
        postMid(root.right)
        res.push(root.val)
    }
    postMid(root)
    return res
};
```

- 迭代算法

> 借助栈

```js
var postorderTraversal = function(root) {
    if (!root) return []
    let res = [];
    let stack = [root];
    while(stack.length) {
        let node = stack.pop();
        res.unshift(node.val);
        node.left && stack.push(node.left)
        node.right && stack.push(node.right)
    }
    return res
};
```

## 147. [对链表进行插入排序](https://leetcode-cn.com/problems/insertion-sort-list/)

[详细解答](https://leetcode-cn.com/problems/insertion-sort-list/solution/dui-lian-biao-jin-xing-cha-ru-pai-xu-by-leetcode-s/)

```txt
时间复杂度：O(N^2)
空间复杂度：O(1)
```

```js
var insertionSortList = function(head) {
    if (!head) return null;
    let pHead = new ListNode(-Infinity);
    pHead.next = head;
    let curr = head.next, lastSorted = head;
    while (curr) {
        if (curr.val >= lastSorted.val) {
            lastSorted = curr;
        } else {
            let pre = pHead;
            while (pre.next.val <= curr.val) {
                pre = pre.next;
            }
            lastSorted.next = curr.next;
            curr.next = pre.next;
            pre.next = curr;
        }
        curr = lastSorted.next;
    }
    return pHead.next;
};
```

## 148. [排序链表](https://leetcode-cn.com/problems/sort-list/)

[进阶详细解答](https://leetcode-cn.com/problems/sort-list/solution/pai-xu-lian-biao-by-leetcode-solution/)

```txt
此方法与 147 题一样

时间复杂度：O(N^2)
空间复杂度：O(1)
```

```js
var insertionSortList = function(head) {
    if (!head) return null;
    let pHead = new ListNode(-Infinity);
    pHead.next = head;
    let curr = head.next, lastSorted = head;
    while (curr) {
        if (curr.val >= lastSorted.val) {
            lastSorted = curr;
        } else {
            let pre = pHead;
            while (pre.next.val <= curr.val) {
                pre = pre.next;
            }
            lastSorted.next = curr.next;
            curr.next = pre.next;
            pre.next = curr;
        }
        curr = lastSorted.next;
    }
    return pHead.next;
};
```

## 160. [相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists)

```txt
相交链表 headA headB，同时遍历这两个链表，当headA遍历完了遍历headB，当headB遍历完了遍历headA
也就是遍历一次headA+headB（拼起来）和headB+headA

headA: 4->1->8->4->5
headB: 5->0->1->8->4->5

headA+headB: 4->1->8->4->5->5->0->1->8->4->5
headB+headA: 5->0->1->8->4->5->4->1->8->4->5

可以看到在8的地方相遇了
```

```js
var getIntersectionNode = function(headA, headB) {
    let p1=headA;
    let p2=headB;
    while(true){
        if(p1 === p2) return p1;
        p1 = p1 ? p1.next : headB;
        p2 = p2 ? p2.next : headA;
    }
};
```

## 164. [最大间距](https://leetcode-cn.com/problems/maximum-gap/)

```txt
时间复杂度：O(NlogN)， sort 排序的时间复杂度
空间复杂度：O(logN)， sort 排序的空间复杂度
```

```js
var maximumGap = function (nums) {
    if (nums.length < 2) return 0;
    nums.sort((a, b) => a - b);
    let minDiff = 0;
    for (let i = 1; i < nums.length; i++) {
        minDiff = Math.max(minDiff, nums[i] - nums[i-1])
    }
    return minDiff
};
```

## 189. [旋转数组](https://leetcode-cn.com/problems/rotate-array/)

### 方法1

```txt
循环 k 次：将数组最后一个元素弹出，添加到数组头部
```

- 时间复杂度：O($k*n$)
- 空间复杂度：O(1)

```js
var rotate = function(nums, k) {
    while (k > 0) {
        nums.unshift(nums.pop())
        k--;
    }
    return nums
};
```

### 方法2

```txt
当我们将数组的元素向右移动 k 次后，尾部 k%n 个元素会移动至数组头部，其余元素向后移动 k%n 个位置。

我们可以先将所有元素翻转，这样尾部的 k%n 个元素就被移至数组头部，然后我们再翻转 [0, k%n-1] 区间的元素和 [k%n, n-1] 区间的元素即能得到最后的答案。
```

- 时间复杂度：O($n$)，其中 n 为数组的长度。每个元素被翻转两次，一共 n 个元素，因此总时间复杂度为 O($2n$) = O($n$)。
- 空间复杂度：O(1)

```js
var rotate = function (nums, k) {
    const reverse = (nums, start, end) => {
        while (start < end) {
            [nums[start], nums[end]] = [nums[end], nums[start]]
            start++;
            end--;
        }
    }
    const n = nums.length;
    k = k % n;
    reverse(nums, 0, n - 1)
    reverse(nums, 0, k - 1)
    reverse(nums, k, n - 1)
    return nums
};
```

## 200. [岛屿数量](https://leetcode-cn.com/problems/number-of-islands)

```txt
深度优先遍历，找到一个为1（陆地）的，count++，同时将其上下左右的陆地都变成0（湖泊）
```

```js
var numIslands = function(grid) {
    let rows = grid.length;
    if (rows === 0) return 0;
    let cols = grid[0].length;
    let count = 0;
    for(let i=0;i<rows;i++) {
        for(let j=0; j<cols; j++) {
            if (grid[i][j] === '1') {
                count++;
                dfs(grid, i, j, rows, cols);
            }
        }
    }
    return count;
};

function dfs(grid, i, j, rows, cols) {
    if (i<0 || j<0 || i>rows-1 || j>cols-1 || grid[i][j] === '0') return;
    grid[i][j] = '0';
    dfs(grid, i-1, j, rows, cols);
    dfs(grid, i+1, j, rows, cols);
    dfs(grid, i, j-1, rows, cols);
    dfs(grid, i, j+1, rows, cols);
}
```

## 203. [移除链表元素](https://leetcode-cn.com/problems/remove-linked-list-elements)

```txt
哨兵节点 + 双指针法
```

```js
var removeElements = function(head, val) {
    let node = new ListNode(-1);
    node.next = head;
    let pre = node;
    let cur = node.next
    while(cur) {
        if(cur.val === val) {
            pre.next = cur.next;
            cur = pre.next;
        }else{
            pre = cur;
            cur = cur.next;
        }
    }
    return node.next;
};
```

## 204. [计数质数](https://leetcode-cn.com/problems/count-primes/)

- 枚举法

    时间复杂度：O(n ($\sqrt{n}$) )

    空间复杂度：O(1)

```js
var countPrimes = function (n) {
    if (n === 0 || n === 1) return 0;
    let isPrime = n => {
        for (let i = 2; i <= Math.sqrt(n); i++) {
            if (n % i === 0) return false;
        }
        return true;
    }
    let ans = 0;
    for (let i = 2; i < n; i++) {
        if (isPrime(i)) {
            ans++;
        }
    }
    return ans;
};
```

## 205. [同构字符串](https://leetcode-cn.com/problems/isomorphic-strings/)

```txt
双射：s 的任意一个字符被 t 中唯一的字符对应，同时 t 的任意一个字符被 s 中唯一的字符对应。

时间复杂度：O(n)，n为字符串的长度
空间复杂度：O(Σ)，Σ≤n
```

```js
var isIsomorphic = function (s, t) {
    let s2t = {}, t2s = {};
    for (let i = 0; i < s.length; i++) {
        let x = s[i], y = t[i];
        if ((s2t[x] && t2s[y] !== x) || (t2s[y] && s2t[x] !== y)) {
            return false
        }
        s2t[x] = y;
        t2s[y] = x;
    }
    return true
};
```

## 206. [反转链表](https://leetcode-cn.com/problems/reverse-linked-list)

```txt
思路1: 用一个数组存储链表的val

思路2: 迭代
  一次遍历 时间复杂度O(N)，空间复杂度O(1)

思路3: 递归
```

```js
// 思路1:
var reverseList = function(head) {
    let arr = [];
    while(head) {
        arr.push(head.val);
        head=head.next;
    }
    arr.reverse();
    let node = new ListNode(-1);
    let p = node;
    arr.forEach(item => {
        p.next = new ListNode(item);
        p=p.next;
    })
    return node.next;
};

// 思路2：
var reverseList = function(head) {
    let [pre, cur] = [null, head];
    while(cur) {
        let tmp = cur.next; //临时存储下一个节点
        cur.next = pre; // 反转链表
        pre = cur; // 接收链表反转的结果
        cur = tmp; // 接回临时存储的后续内容
    }
    return pre;
};

// 思路3:
var reverseList = function(head) {
    if(!head || !head.next) return head;
    let next = head.next; // next节点，反转后是最后一个节点
    let reverseListNode = reverseList(next);
    head.next = null; // 裁减 head
    next.next = head; // 尾接
    return reverseListNode;
};
```

## 209. [长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum)

```txt
滑动窗口法，时间复杂度O(N)，空间复杂度O(1)
```

```js
var minSubArrayLen = function(s, nums) {
    let minLen = Infinity;
    let i = 0;
    let j = 0;
    let sum = 0;
    while(j < nums.length) {
        sum += nums[j];
        while(sum >= s) {
            minLen = Math.min(minLen, j-i+1);
            sum -= nums[i];
            i++;
        }
        j++;
    }
    return minLen === Infinity ? 0 : minLen;
};
```

## 215. [数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array)

```txt
TopK问题：
思路1：排序，取第k个
思路2：构造前 k 个最大元素小顶堆，取堆顶
思路3:快排
```

```js
// 思路1，时间复杂度O(N^2)
var findKthLargest = function(nums, k) {
    nums.sort((a,b) => b-a);
    return nums[k-1];
};

// 思路2
var findKthLargest = function(nums, k) {
    // 从 nums 中取出前 k 个数，构建一个小顶堆
    let heap = [,], i = 0
    while(i < k) {
       heap.push(nums[i++])
    }
    buildHeap(heap, k)
    // 从 k 位开始遍历数组
    for(let i = k; i < nums.length; i++) {
        if(heap[1] < nums[i]) {
            // 替换并堆化
            heap[1] = nums[i]
            heapify(heap, k, 1)
        }
    }
    // 返回堆顶元素
    return heap[1]
};

// 原地建堆，从后往前，自上而下式建小顶堆
let buildHeap = (arr, k) => {
    if(k === 1) return
    // 从最后一个非叶子节点开始，自上而下式堆化
    for(let i = Math.floor(k/2); i>=1 ; i--) {
        heapify(arr, k, i)
    }
}

// 堆化
let heapify = (arr, k, i) => {
    // 自上而下式堆化
    while(true) {
        let minIndex = i
        if(2*i <= k && arr[2*i] < arr[i]) {
            minIndex = 2*i
        }
        if(2*i+1 <= k && arr[2*i+1] < arr[minIndex]) {
            minIndex = 2*i+1
        }
        if(minIndex !== i) {
            swap(arr, i, minIndex)
            i = minIndex
        } else {
            break
        }
    }
}

// 交换
let swap = (arr, i , j) => {
    let temp = arr[i]
    arr[i] = arr[j]
    arr[j] = temp
}

// 思路3
let findKthLargest = function(nums, k) {
    return quickSelect(nums, nums.length - k)
};

let quickSelect = (arr, k) => {
  return quick(arr, 0 , arr.length - 1, k)
}

let quick = (arr, left, right, k) => {
  let index;
  if(left < right) {
    // 划分数组
    index = partition(arr, left, right)
    // Top k
    if(k === index) {
        return arr[index]
    } else if(k < index) {
        // Top k 在左边
        return quick(arr, left, index-1, k)
    } else {
        // Top k 在右边
        return quick(arr, index+1, right, k)
    }
  }
  return arr[left]
}

let partition = (arr, left, right) => {
  // 取中间项为基准
  var datum = arr[Math.floor(Math.random() * (right - left + 1)) + left],
      i = left,
      j = right
  // 开始调整
  while(i < j) {
    // 左指针右移
    while(arr[i] < datum) {
      i++
    }
    // 右指针左移
    while(arr[j] > datum) {
      j--
    }
    // 交换
    if(i < j) {
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }

    // 当数组中存在重复数据时，即都为datum，但位置不同
    // 继续递增i，防止死循环
    if(arr[i] === arr[j] && i !== j) {
        i++
    }
  }
  return i
}
```

## 217. [存在重复元素](https://leetcode-cn.com/problems/contains-duplicate/)

```txt
时间复杂度：O(N)
空间复杂度：O(N)
```

```js
var containsDuplicate = function(nums) {
    return [...new Set(nums)].length !== nums.length
};
```

## 222. [完全二叉树的节点个数](https://leetcode-cn.com/problems/count-complete-tree-nodes/)

```txt
时间复杂度：O(N^2)
空间复杂度：O(1)
```

```js
var countNodes = function(root) {
    if (!root) return 0;
    return 1 + countNodes(root.left) + countNodes(root.right)
};
```

## 228. [汇总区间](https://leetcode-cn.com/problems/summary-ranges/)

```txt
题解

一次遍历即可，遍历 nums[i]，判断 nums[i+1] 是不是比 nums[i] 大 1:

    如果是说明形成一个区间，继续往后找，知道找一个数 nums[j] 不满足条件，这个时候 [i, j] 区间内的数就是一个区间，区间就是 nums[i] -> nums[j]]

    如果不是就说明这个数就是一个区间 nums[i]
```

- 时间复杂度：O($n$)，n 是 nums 的长度。
- 空间复杂度：O(1)，除了用于输出的空间外，额外使用的空间为常数。

```js
var summaryRanges = function (nums) {
    let ret = [];
    const n = nums.length;
    for (let i = 0; i < n;) {
        let j = i;
        if (nums[j] + 1 === nums[j + 1]) {
            while (nums[j] + 1 === nums[j + 1]) {
                j++;
            }
            ret.push([nums[i], nums[j]].join('->'))
            i = j + 1;
        } else {
            ret.push('' + nums[i])
            i++;
        }
    }
    return ret
};
```

## 234. [回文链表](https://leetcode-cn.com/problems/palindrome-linked-list)

```txt
思路1：
用一个数组存储每个节点的值，时间复杂度O(N)，空间复杂度O(N)

思路2:进阶：你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？
快慢指针 + 逆反链表：快指针每次两步，慢指针一步，在慢指针走的时候将每一步的指针反向，例如：1->2->4->2->1
  慢指针：2->4->2->1 快指针：4->2->1 逆反指针：1->null
  慢指针：4->2->1    快指针：1       逆反指针：2->1
这里注意处理一下链表个数为奇数的情况：需要继续让慢指针向后走一步
最后同时遍历慢指针和逆反指针，判断是否相等即可。
```

```js
// 思路1
var isPalindrome = function(head) {
    let arr = [];
    let p = head;
    while(p) {
        arr.push(p.val);
        p = p.next;
    }
    return arr.join('') === arr.reverse().join('');
};

// 思路2
var isPalindrome = function(head) {
    let mid = head;
    let reversed = null;
    let pre = null;
    while(head && head.next) {
        // 先把mid节点保存一下
        pre = mid;
        head = head.next.next;// 走两步
        mid = mid.next; // 走一步
        // reversed是上一轮遍历的pre节点，将指针反向：pre->pre.next变成pre.next->pre
        pre.next = reversed;
        reversed = pre;
    }
    if(head) { // 奇数的情况，要将mid再往后移动一位
        mid = mid.next;
    }
    while(mid && reversed) {
        if(mid.val !== reversed.val) {
            return false;
        }
        mid = mid.next;
        reversed = reversed.next;
    }
    return true;
};
```

## 239. [滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)

### 方法1： 暴力法

- 时间复杂度：O((n-k-1) * k)，n 是 nums 的长度。总共 n-k-1 个滑动窗口，每个滑动窗口的找最大值的复杂度为 O(k)，这种方式超出了题的时间限制。
- 空间复杂度：O(1)

```js
var maxSlidingWindow = function (nums, k) {
    const res = [];
    for (let i = 0; i <= nums.length - k; i++) {
        res.push(Math.max(...nums.slice(i, i + k)));
    }
    return res;
};
```

### 方法2：滑动窗口 + 双端队列

```txt
题解：

双端队列：
    每次push元素时，将队列中更小元素删除，直到不小时
    每次pop元素时，如果是更小的元素在push时就已经删除了，只需要判断是否是头部最大值，是再删除一遍头部元素即可
```

- 时间复杂度：O(n)
- 空间复杂度：O(n)

```js
var maxSlidingWindow = function (nums, k) {
    class slideWindow {
        constructor() {
            this.deque = [];
        }
        push(val) { // 队列从尾部开始，把小于val的数都去掉，然后将val加入队列末尾
            while (this.deque.length > 0 && this.deque[this.deque.length - 1] < val) {
                this.deque.pop()
            }
            this.deque.push(val)
        }
        pop(val) { // 判断以下队首元素是不是val（最大值）,是就删除，不是就跳过
            if (this.deque.length > 0 && this.deque[0] === val) {
                this.deque.shift()
            }
        }
        max() {
            return this.deque[0]
        }
    }
    let window = new slideWindow();
    let res = [];
    const n = nums.length;
    for (let i = 0; i < n; i++) {
        if (i < k - 1) {
            window.push(nums[i])
        } else {
            window.push(nums[i]);
            res.push(window.max())
            window.pop(nums[i - k + 1]) // 判断滑动窗口的左边元素是不是window的左边元素，是的话就弹掉
        }
    }
    return res;
};
```

## 242. [有效的字母异位词](https://leetcode-cn.com/problems/valid-anagram/)

```txt
方法1：排序
    时间复杂度：O(nlogn)
    空间复杂度：O(logn)

方法2：哈希表
    时间复杂度：O(n)
    空间复杂度：O(S)，S 是 table 的大小 （S = 26）
```

```js
// 方法1
var isAnagram = function(s, t) {
    s = s.split('').sort().join('');
    t = t.split('').sort().join('');
    return s === t
};

// 方法2
var isAnagram = function (s, t) {
    const table = Array(26).fill(0);
    for (let str of s) {
        let index = str.charCodeAt() - 'a'.charCodeAt()
        table[index]++;
    }
    for (let str of t) {
        let index = str.charCodeAt() - 'a'.charCodeAt()
        table[index]--;
        if (table[index] < 0) return false
    }
    return table.every(e => e === 0)
};
```

## 283. [移动零](https://leetcode-cn.com/problems/move-zeroes/)

```txt
双指针法：
    左指针指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。
    右指针不断向右移动，每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移。

时间复杂度：O(N)
空间复杂度：O(1)
```

```js
var moveZeroes = function (nums) {
    const n = nums.length;
    let [i, j] = [0, 0];
    while (j < n) {
        if (nums[j] !== 0) {
            [nums[i], nums[j]] = [nums[j], nums[i]];
            i++;
        }
        j++;
    }
    return nums
};
```

## 290. [单词规律](https://leetcode-cn.com/problems/word-pattern/)

```txt
pattern 与 str 里的字符要满足双向映射，即 pattern 里的每个字符映射 str 的一个单词，同时 str 里的每个单词映射 pattern 里的一个字符

时间复杂度：O(n + m)，其中 n 为 pattern 的长度，m 为 str 的长度。插入和查询哈希表的均摊时间复杂度均为 O(n + m)。每一个字符至多只被遍历一次。
空间复杂度：O(n + m)，最坏情况下，我们需要存储 pattern 中的每一个字符和 str 中的每一个字符串。
```

```js

```

## 300. [最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence)

- 动态规划

```txt
dp[i]表示的是前i个字符中最长上升子序列的个数
```

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var lengthOfLIS = function (nums) {
    let len = nums.length;
    if (len < 1) return 0;
    let dp = Array(len).fill(1);
    for (let i = 0; i < len; i++) {
        for (let j = 0; j < i; j++) {
            if (nums[j] < nums[i]) {
                dp[i] = Math.max(dp[i], dp[j] + 1);
            }
        }
    }
    return Math.max(...dp);
};
```

## 316. [去除重复字母](https://leetcode-cn.com/problems/remove-duplicate-letters/)

参考[官方题解](https://leetcode-cn.com/problems/remove-duplicate-letters/solution/qu-chu-zhong-fu-zi-mu-by-leetcode-soluti-vuso/)

```txt
贪心 + 栈

时间复杂度：O(N)，其中 NN 为字符串长度。
空间复杂度：O(∑)，∑ = 26
```

```js
var removeDuplicateLetters = function (s) {
    const vis = Array(26).fill(0); // 记录每个字符是否在栈中出现
    const nums = {}; // 记录每个字符出现的次数
    for (let i = 0; i < s.length; i++) {
        let ch = s[i];
        if (nums[ch] === undefined) {
            nums[ch] = 1;
        } else {
            nums[ch]++;
        }
    }
    const stack = []; // 维护一个栈
    for (let i = 0; i < s.length; i++) {
        let ch = s[i];
        if (!vis[ch.charCodeAt() - 'a'.charCodeAt()]) { // 栈中不存在ch这个字符
            while (stack.length > 0 && stack[stack.length - 1] > ch) {
                if (nums[stack[stack.length - 1]] > 0) { // 栈顶元素在后面的字符中存在
                    // 标记栈顶元素在栈中不存在 并弹出栈顶元素
                    vis[stack[stack.length - 1].charCodeAt() - 'a'.charCodeAt()] = 0;
                    stack.pop();
                } else {
                    break;
                }
            }
            vis[ch.charCodeAt() - 'a'.charCodeAt()] = 1; // 标记字符ch在栈中出现过
            stack.push(ch);
        }
        nums[ch]--; // 每次遍历完将这个字符出现的次数减1
    }
    return stack.join('')
};
```

## 328. [奇偶链表](https://leetcode-cn.com/problems/odd-even-linked-list/)

```txt
维护两个指针，一个奇数指针，一个偶数指针，一次遍历就可以将奇数节点连在一起，偶数节点连在一起，最后再把奇数节点的最后一个连接到偶数节点的第一个。

时间复杂度：O(N)，N 为链表的长度
空间复杂度：O(1)
```

```js
var oddEvenList = function(head) {
    if (!head) return null;
    let evenHead = head.next;
    let odd = head, even = evenHead;
    while(even && even.next) {
        odd.next = even.next;
        odd = odd.next;
        even.next = odd.next;
        even = even.next;
    }
    odd.next = evenHead;
    return head;
};
```

## 344. [反转数组](https://leetcode-cn.com/problems/reverse-string)

> 要求不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。

```txt
时间复杂度：O(N)
空间复杂度：O(1)
```

```js
var reverseString = function (s) {
    let [l, r] = [0, s.length - 1];
    for (let i = 0; i < s.length >> 1; i++) {
        [s[l], s[r]] = [s[r], s[l]];
        l++;
        r--;
    }
    return s;
};
```

## 347. [前 K 个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements)

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */
var topKFrequent = function (nums, k) {
    let map = new Map();
    nums.forEach((item, index) => {
        if (map.has(item)) {
            map.set(item, map.get(item) + 1);
        } else {
            map.set(item , 1);
        }
    })
    let arr = [...map.keys()]; // 不重复的数字
    if (arr.length < k) return arr;

    function adjustHeap(nums, i, len) { // 小顶堆
        for (let j = 2 * i + 1; j < len; j = 2 * j + 1) {
            if (j + 1 < len && map.get(nums[j]) > map.get(nums[j + 1])) {
                j++;
            }
            if (map.get(nums[i]) > map.get(nums[j])) {
                [nums[i], nums[j]] = [nums[j], nums[i]];
                i = j;
            } else {
                break;
            }
        }
    }
    let a = arr.splice(0, k);
    for (let i = (k-1) >> 1 ; i >= 0; i--) {
        adjustHeap(a, i, a.length);
    }
    for (let i = 0; i < arr.length; i++) {
        if (map.get(arr[i]) > map.get(a[0])) {
            a[0] = arr[i];
            adjustHeap(a, 0, k);
        }
    }
    return a
};
```

## 349. [两个数组的交集](https://leetcode-cn.com/problems/intersection-of-two-arrays/)

```txt
时间复杂度：O(m + n)，m, n 分别是两个数组的长度。使用两个集合分别存储两个数组中的元素需要 O(m+n) 的时间，遍历较小的集合并判断元素是否在另一个集合中需要 O(min(m,n)) 的时间，因此总时间复杂度是 O(m+n)。

空间复杂度：O(m + n)，空间复杂度主要取决于两个集合。
```

```js
var intersection = function(nums1, nums2) {
    let s1 = new Set(nums1);
    let s2 = new Set(nums2);
    let res = [];
    s1.forEach(item => {
        if (s2.has(item)) {
            res.push(item)
        }
    })
    return res;
};
```

## 387. [字符串中的第一个唯一字符](https://leetcode-cn.com/problems/first-unique-character-in-a-string/)

```txt
方法1：暴力法
    时间复杂度：O(n^2)
    空间复杂度：O(1)

方法2：哈希表
    时间复杂度：O(n)
    空间复杂度：O(∑)， ∑ < 26
```

```js
// 方法1
var firstUniqChar = function(s) {
    for (let i=0; i<s.length; i++) {
        if (s.indexOf(s[i]) === s.lastIndexOf(s[i])) {
            return i
        }
    }
    return -1
};

// 方法2
var firstUniqChar = function(s) {
    const map = new Map();
    for (let i=0; i<s.length; i++) {
        if (map.has(s[i])) {
            map.set(s[i], -1);
        } else {
            map.set(s[i], i)
        }
    }
    let res = s.length;
    for (let index of map.values()) {
        if (index !== -1 && index < res) {
            res = index
        }
    }
    if (res === s.length) return -1;
    return res
};
```

## 389. [找不同](https://leetcode-cn.com/problems/find-the-difference/)

```txt
- 哈希映射

    时间复杂度：O(m + n)，m n 分别为字符串 s 和 t 的长度
    空间复杂度：O(max(m, n))

- 求和
    求出字符串 s 和字符串 t 各种字符 ASCII 码和，相差的码数就是所要找的字符
    
    时间复杂度：O(m + n)，m n 分别为字符串 s 和 t 的长度
    空间复杂度：O(1)
```

```js
、、 哈希映射
var findTheDifference = function (s, t) {
    let map = new Map();
    for (const ch of s) {
        if (map.has(ch)) {
            map.set(ch, map.get(ch) + 1)
        } else {
            map.set(ch, 1)
        }
    }
    for (const ch of t) {
        if (!map.has(ch) || map.get(ch) === 0) {
            return ch
        }
        map.set(ch, map.get(ch) - 1)
    }
};

// 求和
var findTheDifference = function (s, t) {
    let as = 0, at = 0
    for (const ch of s) {
        as += ch.charCodeAt()
    }
    for (const ch of t) {
        at += ch.charCodeAt()
    }
    return String.fromCharCode(at -as)
};
```

## 399. [除法求值](https://leetcode-cn.com/problems/evaluate-division/)

```txt
题解：邻接表

我们将这种关系表示为存储为邻接表

         2
    ————————————>
a                     b
    <————————————
        1/2        ∧     |
                   |     |
                3  |     | 1/3
                   |     |
                   |     ∨

                      c

邻接表的格式为
map = {
    a: { b: 2 },
    b: { a: 1/2, c: 3 },
    c: { b: 1/3 }
}

然后我们再扩展出所有可能的情况，例如 a/b 和 b/c 可以扩展到 a/c

最后只要对 queries 数组遍历得到结果即可
```

- 时间复杂度：O($n^3$)
- 空间复杂度：O($n$)

```js
var calcEquation = function (equations, values, queries) {
    let map = {};
    // 定义一个对象，map[x][y] 表示 x/y 的值
    equations.forEach((e, i) => {
        if (!map[e[0]]) map[e[0]] = {};
        if (!map[e[1]]) map[e[1]] = {};
        map[e[0]][e[1]] = values[i]
        map[e[1]][e[0]] = 1 / values[i]
    })
    const keys = Object.keys(map);
    keys.forEach(x => {
        keys.forEach(y => {
            map[x][y] && keys.forEach(z => { // 如果 x/y 有值 y/z 也有值，则 x/z 的值也可以求出
                if (map[y][z]) {
                    map[x][z] = map[x][y] * map[y][z]
                    map[z][x] = 1 / map[x][z] // 这行不加会有一个测试案例通过不了
                }
            })
        })
    })
    return queries.map(e => {
        return map[e[0]] && map[e[0]][e[1]] ? map[e[0]][e[1]] : -1
    })
};
```

## 402. [移掉K位数字](https://leetcode-cn.com/problems/remove-k-digits/)

[官网解析](https://leetcode-cn.com/problems/remove-k-digits/solution/yi-diao-kwei-shu-zi-by-leetcode-solution/)

```js
var removeKdigits = function(num, k) {
    const stk = [];
    for (let n of num) {
        while (stk.length && stk[stk.length - 1] > n && k > 0) {
            stk.pop();
            k--;
        }
        stk.push(n);
    }
    while(k > 0) {
        stk.pop();
        k--;
    }
    let ans = '';
    let isLeadingZero = true;
    for(let number of stk) {
        if (isLeadingZero && number === '0') {
            continue
        }
        isLeadingZero = false;
        ans += number
    }
    return ans === '' ? '0' : ans;
};
```

## 406. [根据身高重建队列](https://leetcode-cn.com/problems/queue-reconstruction-by-height/)

[官网解析](https://leetcode-cn.com/problems/queue-reconstruction-by-height/solution/gen-ju-shen-gao-zhong-jian-dui-lie-by-leetcode-sol/)

```txt
时间复杂度：O(N^2)
空间复杂度：O(logN)
```

```js
var reconstructQueue = function(people) {
    people.sort((a, b) => { // （h, k） 按照身高排序，身高相同的 k 大的排前面
        if (a[0] === b[0]) {
            return b[1] - a[1]
        } else {
            return a[0] - b[0]
        }
    });
    const res = Array(people.length);
    // 初始化一个长度为n的一个队列，排序后的每个元素（h, k）就站在第k + 1 个空位（即前面有k个人身高大于等于h）
    people.forEach(item => {
        let index = item[1] + 1;
        for(let i=0; i<res.length; i++) {
            if (res[i] === undefined) {
                index--;
                if (index === 0) {
                    res[i] = item;
                    break;
                }
            }
        }
    })
    return res;
};
```

## 416. [分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum)

[一个比较好的解释](https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/bei-bao-zi-ji)

```txt
换句话描述就是能否找到一个组合的和等于 nums 的和的一半，也就转换成了 0-1 背包问题
套用动态规划模板来求解

因为有两个状态，【背包的容量】和【可选择的物品】，所以 dp 是一个二维数组

dp定义为：
dp[n][sum] 表示前 n 个数中能否找到一个和为 sum 的组合

状态转移方程：
dp[i][j] = dp[i - 1][j - nums[i - 1]] || dp[i - 1][j]
意思是第i个数有两种选择：选或不选，不选就是继承之前的结果，选了就是判断在装第 i 个数之前是否有一种组合的和为 j - num[i - 1]，很好理解

再处理一下边界问题，

时间复杂度：O(n * sum)，其中 n 为 nums 的长度，sum 为 nums 数组和的一半。
空间复杂度：O(n * sum)
```

```js
var canPartition = function (nums) {
    let sum = nums.reduce((t, v) => t + v);
    if (sum % 2 !== 0) return false;
    sum = sum / 2;
    let len = nums.length;
    let dp = Array(len + 1).fill('').map(e => Array(sum + 1).fill(false))
    for (let i = 0; i <= len; i++) {
        dp[i][0] = true
    }
    for (let i = 1; i <= len; i++) {
        for (let j = 1; j <= sum; j++) {
            if (j - nums[i - 1] < 0) {
                dp[i][j] = dp[i - 1][j]
            } else {
                dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i - 1]]
            }
        }
    }
    return dp[len][sum]
};
```

## 435. [无重叠区间](https://leetcode-cn.com/problems/non-overlapping-intervals/)

```txt
动态规划
先对区间按左端点升序

（1）定义dp矩阵
    dp[i] 表示以区间 i 结尾的前 i 个区间中不重叠的的最大区间数
（2）转移方程：
    dp[i] = min{dp[j]} + 1, j ＜ i
    若第j个区间的右端点Rj如果小于第i个区间的左端点，那第j个区间就与第i个区间不重叠
    若找不到这样一个区间j，dp[i] = 1
（3)dp矩阵中最大的数就是所有区间中最大的不重叠区间数，最小需要移除的区间数就用总的区间数减去最大不重叠的区间数

```

```js
var eraseOverlapIntervals = function(intervals) {
    if (!intervals.length) return 0;
    intervals.sort((a,b) => a[0] - b[0])
    const n = intervals.length;
    let dp = Array(n).fill(1);
    for (let i=1; i<n; i++) {
        for (let j=0; j<i; j++) {
            if (intervals[j][1] <= intervals[i][0]) {
                dp[i] = Math.max(dp[i], dp[j] + 1)
            }
        }
    }
    return n - Math.max(...dp)
};
```

## 452. [用最少数量的箭引爆气球](https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/)

```txt
先对 points 排个序，然后两两找交集，找到就把交集继续与下一个比较，没有交集就更新count

时间复杂度：O(nlogn)，排序时间复杂度
空间复杂度：O(logn)，排序的空间复杂度
```

```js
var findMinArrowShots = function (points) {
    if (points.length === 0) return 0;
    // 这个函数是用来求 s1 和 s2 的交集，如果不存在交集返回 false
    let crossSet = (s1, s2) => {
        let [a, b] = s1;
        let [c, d] = s2;
        if (c <= b) {
            return [Math.max(a, c), Math.min(b, d)];
        } else return false;
    }

    points.sort((a, b) => a[0] - b[0])
    let res = points[0];
    let count = 1;
    for (let i = 1; i < points.length; i++) {
        debugger
        res = crossSet(res, points[i]);
        if (!res) {
            count++;
            res = points[i];
        }
    }
    return count;
};
```

## 454. [四数相加 II](https://leetcode-cn.com/problems/4sum-ii/)

```txt
A + B + C + D = 0
可以转换成 -(A + B) = C + D
那么可以用哈希表 map 保存一下-(A + B) 出现的次数，然后遍历 C + D 即可

时间复杂度：O(N^2)
空间复杂度：O(N^2)
```

```js
var fourSumCount = function (A, B, C, D) {
    let map = new Map();
    A.forEach(u => {
        B.forEach(v => {
            if (map.has(-u-v)) {
                map.set(-u - v, map.get(-u - v) + 1);
            } else {
                map.set(-u - v, 1);
            }
        })
    })
    let count = 0;
    for (let i of C) {
        for (let j of D) {
            if (map.has(i + j)) {
                count += map.get(i + j);
            }
        }
    }
    return count
};
```

## 455. [分发饼干](https://leetcode-cn.com/problems/assign-cookies/)

```txt
排序 + 双指针法

时间复杂度：O(mlogm + nlogn)，其中m是g的长度，n是s的长度
空间复杂度：O(logm + logn)，空间复杂度主要是排序的额外空间开销。
```

```js
var findContentChildren = function (g, s) {
    g.sort((a, b) => a - b)
    s.sort((a, b) => a - b)
    let ret = 0;
    let i = 0, j = 0;
    while (i < g.length && j < s.length) {
        if (s[j] >= g[i]) {
            ret++;
            i++;
            j++;
        } else {
            j++
        }
    }
    return ret;
};
```

## 463. [岛屿的周长](https://leetcode-cn.com/problems/island-perimeter/)

```txt
换种理解：
对于一个陆地格子的每条边，它被算作岛屿的周长当且仅当这条边为网格的边界或者相邻的另一个格子为水域。
因此，我们可以遍历每个陆地格子，看其四个方向是否为边界或者水域，如果是，将这条边的贡献（即 1）加入答案 ans 中即可。

时间复杂度：O(m*n)，m 和 n 分别是网格的高和宽
空间复杂度：O(1)
```

```js
var islandPerimeter = function (grid) {
    let ans = 0;
    const m = grid.length;
    const n = grid[0].length;
    const dx = [0, 1, 0, -1];
    const dy = [1, 0, -1, 0];
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            if (grid[i][j]) {
                for (let k = 0; k < 4; k++) {
                    let tx = i + dx[k];
                    let ty = j + dy[k];
                    if (tx < 0 || tx >= m || ty < 0 || ty >= n || !grid[tx][ty]) {
                        ans++;
                    }
                }
            }
        }
    }
    return ans
};
```

## 494. [目标和](https://leetcode-cn.com/problems/target-sum)

- 回溯法

```js
/**
 * @param {number[]} nums
 * @param {number} S
 * @return {number}
 */
var findTargetSumWays = function(nums, S) {
    if (nums.length === 0) return 0;
    let result = 0;
    let helper = (nums, i, sum, S) => {
        if (i === nums.length) {
            if (sum === S) {
                result++;
            }
            return;
        }
        helper(nums, i+1, sum+nums[i], S);
        helper(nums, i+1, sum-nums[i], S);
    }
    helper(nums, 0, 0, S);
    return result;
};
```

## 509. [斐波那契数](https://leetcode-cn.com/problems/fibonacci-number/)

```txt
时间复杂度：O(n)
空间复杂度：O(1)
```

```js
var fib = function(n) {
    let a = -1, b = 1, res = 0;
    for (let i=2; i<=n; i++) {
        res = a+b;
        a = b;
        b = res;
    }
    return res;
};
```

## 518. [零钱兑换Ⅱ](https://leetcode-cn.com/problems/coin-change-2)

[参考一个比较清晰的解读](https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/bei-bao-ling-qian)

```txt
时间复杂度：O(n * amount)，其中 n 是 coins 的长度，amount 表示面额
空间复杂度：O(n * amount)
```

```js
var change = function(amount, coins) {
    let n = coins.length;
    let dp = Array(n + 1).fill(0).map(e => Array(amount + 1).fill(0));
    for(let i=0; i<=n; i++) {
        dp[i][0] = 1;
    }
    for(let i=1; i<=n; i++) {
        for(let j=1; j<=amount; j++) {
            if (j - coins[i-1] >= 0) {
                dp[i][j] = dp[i-1][j] + dp[i][j-coins[i-1]];
            } else {
                dp[i][j] = dp[i-1][j];
            }
        }
    }
    return dp[n][amount]
};
```

## 530. [二叉搜索树的最小绝对差](https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/)

与[leetcode783](https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/)相似

```txt
中序遍历 再取中序遍历的结果相邻的数之差的最小值

时间复杂度：O(N)
空间复杂度：O(N)，递归函数的空间复杂度取决于递归的栈深度，而栈深度在二叉搜索树为一条链的情况下会达到 O(N) 级别。
```

```js
var getMinimumDifference = function(root) {
    let min = Infinity, pre = -1;
    let mid = root => {
        if (!root) return;
        mid(root.left);
        if (pre !== -1) {
            min = Math.min(min, root.val - pre);
        }
        pre = root.val;
        mid(root.right);
    }
    mid(root);
    return min
};
```

## 547. [省份数量](https://leetcode-cn.com/problems/number-of-provinces/)

```txt
可以把 n 个城市和它们之间的相连关系看成图，城市是图中的节点，相连关系是图中的边，给定的矩阵 isConnected 即为图的邻接矩阵，省份即为图中的连通分量。

计算省份总数，等价于计算图中的连通分量数，可以通过深度优先搜索或广度优先搜索实现，也可以通过并查集实现。
```

### 深度优先搜索

```txt
深度优先搜索的思路是很直观的。遍历所有城市，对于每个城市，如果该城市尚未被访问过，则从该城市开始深度优先搜索，

通过矩阵 isConnected 得到与该城市直接相连的城市有哪些，这些城市和该城市属于同一个连通分量，然后对这些城市继续深度优先搜索，

直到同一个连通分量的所有城市都被访问到，即可得到一个省份。遍历完全部城市以后，即可得到连通分量的总数，即省份的总数。
```

- 时间复杂度：O($n^2$)，n 是城市的数量。
- 空间复杂度：O($n$)

```js
var findCircleNum = function (isConnected) {
    const n = isConnected.length;
    const visited = new Set();
    // 深度优先搜索
    const dfs = (isConnected, visited, i) => {
        for (let j = 0; j < n; j++) {
            if (isConnected[i][j] === 1 && !visited.has(j)) { // 城市 i 和 j 相连，并且 j 没有并访问过
                visited.add(j);
                dfs(isConnected, visited, j) // 继续遍历和城市j相连的城市，标记已访问过
            }
        }
    }
    let count = 0;
    for (let i = 0; i < n; i++) {
        if (!visited.has(i)) { // 城市 i 没有被访问过
            dfs(isConnected, visited, i);
            count++;
        }
    }
    return count
};
```

### 广度优先搜索

```txt
通过广度优先搜索的方法得到省份的总数。对于每个城市，如果该城市尚未被访问过，则从该城市开始广度优先搜索，

直到同一个连通分量中的所有城市都被访问到，即可得到一个省份。
```

- 时间复杂度：O($n^2$)
- 空间复杂度：O($n$)

```js
var findCircleNum = function (isConnected) {
    const n = isConnected.length;
    const visited = new Set();
    const queue = [];
    let count = 0;
    for (let i = 0; i < n; i++) {
        if (!visited.has(i)) {
            queue.push(i)
            while (queue.length) {
                let j = queue.shift();
                visited.add(j)
                for (let k = 0; k < n; k++) {
                    if (isConnected[j][k] === 1 && !visited.has(k)) {
                        queue.push(k)
                    }
                }
            }
            count++;
        }
    }
    return count;
};
```

## 605. [种花问题](https://leetcode-cn.com/problems/can-place-flowers/)

```txt
跳格子法：
    （1）当遍历到的 i 位置为 1，说明这个位置有花，那必然从i + 2 的位置才可能种花的，因此当碰到1是直接跳过下一格
    （2）当遍历到的 i 位置为 0，前一格必为0（因为每次碰到 1 都是跳两格），此时只需要判断下一格是不是 1 就可以判断这一格能不能种花
        如果能种则花的总数量 count 加一，然后这个位置就按照遇到 1 时处理，即跳两格；
        如果 i 的后一格是 1，说明这个位置不能种花且之后两格也不可能种花，参照（1）直接跳 3 格

时间复杂度：O(m)， m 是 flowerbed 的长度.
空间复杂度：O(1)
```

```js
var canPlaceFlowers = function(flowerbed, n) {
    const m = flowerbed.length;
    let count = 0, i = 0;
    while (i < m) {
        if (flowerbed[i] === 1) {
            i+=2
        } else if (i === m - 1 || flowerbed[i+1] === 0) {
            count++;
            i+=2
        } else {
            i+=3
        }
    }
    return count >= n
};
```

## 628. [三个数的最大乘积](https://leetcode-cn.com/problems/maximum-product-of-three-numbers/)

```txt
先把数组按从小到大排个序,发现无非两种情况:

1. 数组是纯负数,类似 [-4, -3, -2, -1]
    最大乘积就应该是最大的几个数的乘积

2. 数组不是纯负数,
    可能是纯正数,最大的乘积就是最大的几个数的乘积,类似于 [1, 2, 3, 4]
    
    可能是有正有负,那就判断一下最小的两个负数的乘积是不是要比次大的两个正数的乘积大,类似于[-5, -4, 1, 2, 3]
```

- 时间复杂度:O(nlogn)
- 空间复杂度:O(logn)

```js
var maximumProduct = function (nums) {
    const n = nums.length;
    nums.sort((a, b) => a - b)
    return Math.max(nums[0] * nums[1] * nums[n - 1], nums[n - 1] * nums[n - 2] * nums[n - 3])
};
```

## 649. [Dota2 参议院](https://leetcode-cn.com/problems/dota2-senate/)

```txt
用两个队列分别保存 'R' 和 'D' 的索引，模拟整个过程：
    - 如果此时 radiant 或者 dire 为空，那么就可以宣布另一方获得胜利
    - 如果均不为空，那么比较这两个队列的首元素，如果 radiant 的首元素较小，我们会将 dire 的首元素永久地弹出，
    并将 radiant 的首元素弹出，增加 n 之后再重新放回队列

时间复杂度：O(n)
空间复杂度：O(n)
```

```js
var predictPartyVictory = function (senate) {
    let radiant = [], dire = [];
    const n = senate.length;
    for (let i = 0; i < senate.length; i++) {
        if (senate[i] === 'R') {
            radiant.push(i)
        } else {
            dire.push(i)
        }
    }
    while (radiant.length && dire.length) {
        if (radiant[0] < dire[0]) {
            radiant.push(radiant[0] + n)
        } else {
            dire.push(dire[0] + n)
        }
        radiant.shift();
        dire.shift();
    }
    return radiant.length ? "Radiant" : "Dire";
};
```

## 674. [最长连续递增序列](https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/)

### 方法1：动态规划

```txt
dp矩阵的定义
    dp[i] 定义为以 nums[i] 结尾的连续递增子序列的最大长度

转移方程很好理解，dp[i-1] --> dp[i]
    如果 nums[i] > nums[i-1]，那么 dp[i] = dp[i-1] + 1，也就是与前面的组成连续递增子序列
    否则的话，nums[i] 自成一组连续递增子序列，即 dp[i] = 1
```

- 时间复杂度：O(n)，其中 n 是数组 nums 的长度。
- 空间复杂度：O(n)

```js
var findLengthOfLCIS = function(nums) {
    if (!nums.length) return 0;
    const n = nums.length;
    let dp = Array(n).fill(1);
    for (let i=1; i<n; i++) {
        if (nums[i] > nums[i-1]) {
            dp[i] = dp[i-1] + 1;
        }
    }
    return Math.max(...dp)
};
```

### 方法2：贪心

```txt
用一个 start 指针记录连续递增子序列的头部位置，初始时 start = 0，然后遍历数组进行如下操作：

    1. 如果下标 nums[i] ≤ nums[i−1]，则说明当前元素小于或等于上一个元素，因此 nums[i−1] 和 nums[i] 不可能属于同一个连续递增序列，
    必须从下标 i 处开始一个新的连续递增序列，因此令 start=i。如果下标 i=0 或 nums[i] > nums[i−1]，则不更新 start 的值。

    2.此时下标范围 [start,i] 的连续子序列是递增序列，其长度为 i−start+1，使用当前连续递增序列的长度更新最长连续递增序列的长度。
```

- 时间复杂度：O(n)，其中 n 是数组 nums 的长度。
- 空间复杂度：O(1)

```js
var findLengthOfLCIS = function(nums) {
    let start = 0;
    let ret = 0;
    for (let i=0; i<nums.length; i++) {
        if (i > 0 && nums[i] <= nums[i-1]) {
            start = i;
        }
        ret = Math.max(ret, i - start + 1)
    }
    return ret
};
```

## 684. [冗余连接](https://leetcode-cn.com/problems/redundant-connection/)

```txt
并查集

在一棵树中，边的数量比节点的数量少 1。如果一棵树有 N 个节点，则这棵树有 N−1 条边。这道题中的图在树的基础上多了一条附加的边，因此边的数量也是 N。

树是一个连通且无环的无向图，在树中多了一条附加的边之后就会出现环，因此附加的边即为导致环出现的边。

可以通过并查集寻找附加的边。初始时，每个节点都属于不同的连通分量。遍历每一条边，判断这条边连接的两个顶点是否属于相同的连通分量。

    • 如果两个顶点属于不同的连通分量，则说明在遍历到当前的边之前，这两个顶点之间不连通，因此当前的边不会导致环出现，合并这两个顶点的连通分量。

    • 如果两个顶点属于相同的连通分量，则说明在遍历到当前的边之前，这两个顶点之间已经连通，因此当前的边导致环出现，为附加的边，将当前的边作为答案返回。
```

- 时间复杂度：O(NlogN)，其中 N 是图中的节点个数。
- 空间复杂度：O(N)

```js
var findRedundantConnection = function (edges) {
    const nodesCount = edges.length;
    const parent = new Array(nodesCount + 1).fill(0).map((value, index) => index);
    for (let i = 0; i < nodesCount; i++) {
        const [node1, node2] = edges[i];
        if (find(parent, node1) != find(parent, node2)) {
            union(parent, node1, node2);
        } else {
            return edges[i];
        }
    }
    return [0];
};

const union = (parent, index1, index2) => {
    parent[find(parent, index1)] = find(parent, index2);
}

const find = (parent, index) => {
    if (parent[index] !== index) {
        parent[index] = find(parent, parent[index]);
    }
    return parent[index];
}
```

## 714. [买卖股票的最佳时机含手续费](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)

经典股票买卖问题 [一个详细的打包股票买卖问题讲解](https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/1.5-qi-ta-jing-dian-wen-ti/tuan-mie-gu-piao-wen-ti)

```txt
- 状态定义
    dp[i][0] 表示第 i 天不持有股票获得的最大利润
    dp[i][1] 表示第 i 天持有股票获得的最大利润

- 状态转移方程

    要么是昨天我没有持股票今天继续没有持，要么是昨天持股票今天卖掉了
    dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1]+prices[i]-fee)

    要么是昨天我持股票今天继续持，要么是昨天没有持股票今天买入股票
    dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0]-prices[i])

进一步地，状态转移方程，新状态只和相邻的一个状态有关，其实不用整个 dp 数组，只需要一个变量储存相邻的那个状态就足够了，这样可以把空间复杂度降到 O(1)
    dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i] - fee)
    dp_i_1 = Math.max(dp_i_1, dp_i_0 - prices[i])

时间复杂度：O(N)，N 是 prices 的长度
空间复杂度：O(1)
```

```js
var maxProfit = function(prices, fee) {
    /* 这种方式的空间复杂度为 O(N)
    let dp = Array(prices.length).fill(0).map(e => Array(2).fill(0))
    dp[0][0] = 0;
    dp[0][1] = -prices[0];
    for (let i=1; i<prices.length; i++) {
        dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1]+prices[i]-fee)
        dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0]-prices[i])
    }
    return dp[prices.length - 1][0] 
    */

    // 我们观察到状态转移方程，新状态只和相邻的一个状态有关，其实不用整个 dp 数组，只需要一个变量储存相邻的那个状态就足够了，这样可以把空间复杂度降到 O(1)
    let dp_i_0 = 0, dp_i_1 = -prices[0];
    for (let i=1; i<prices.length; i++) {
        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i] - fee)
        dp_i_1 = Math.max(dp_i_1, dp_i_0 - prices[i])
    }
    return dp_i_0
};
```

## 724. [寻找数组的中心索引](https://leetcode-cn.com/problems/find-pivot-index/)

```txt
前缀和的方法

计算所有数字的和为 total，记录左侧元素的和 sum，每次判断 2 * sum 加上当前元素是不是等于所有元素的和 total
```

- 时间复杂度：O(n)，n 为数组 nums 的长度。
- 空间复杂度：O(1)

```js
var pivotIndex = function (nums) {
    const total = nums.reduce((t, v) => t + v, 0);
    let sum = 0;
    for (let i = 0; i < nums.length; i++) {
        if (2 * sum + nums[i] === total) {
            return i
        }
        sum += nums[i]
    }
    return -1;
};
```

## 738. [单调递增的数字](https://leetcode-cn.com/problems/monotone-increasing-digits/)

```txt
- 贪心法：
    从左往右找到N[i-1] > N[i] 的数，将N[i-1]减1，并且需要判断一下该数减 1 后与前 i-1 项是否成递增关系，
    不成递增需要从 i-1 开始递减比较相邻数位的关系，直到找到第一个位置 j 使得 N[j] 自身数位减 1 后 N[j-1] 和 N[j]仍然保持递增关系，或者j=0
    然后我们将j+1往后的数均变成9

    时间复杂度：O(m)，其中 m 是数字 N 的位数
    空间复杂度：O(m)

- 暴力法：（leetcode超出时间限制）
    N 依次减 1，然后判断这个数是否是递增的
```

```js
// 贪心法
var monotoneIncreasingDigits = function (N) {
    let strN = N.toString().split('').map(v => +v);
    let i = 1;
    while (i < strN.length && strN[i - 1] <= strN[i]) {
        i++;
    }
    if (i < strN.length) {
        while (i > 0 && strN[i - 1] > strN[i]) {
            strN[i - 1] -= 1;
            i -= 1;
        }
        for (let j = i + 1; j < strN.length; j++) {
            strN[j] = 9
        }
    }
    return +strN.join('')
};

// 暴力法
var monotoneIncreasingDigits = function (N) {
    let isIncrease = n => {
        let stack = [];
        while (n > 0) {
            if (!stack.length || (n % 10 <= stack[stack.length - 1])) {
                stack.push(n % 10)
            } else {
                return false
            }
            n = parseInt(n / 10)
        }
        return true;
    }
    for (let n = N; n >= 0; n--) {
        if (isIncrease(n)) {
            return n;
        }
    }
};
```

## 746. [使用最小花费爬楼梯](https://leetcode-cn.com/problems/min-cost-climbing-stairs/)

```txt
简单的动态规划题

dp矩阵定义
    dp[i] 定义为前i个阶梯耗费的最小体力

状态转移方程
    dp[i] = Math.min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2])

目标
    dp[n]

时间复杂度：O(n)
空间复杂度：O(1)
```

```js
var minCostClimbingStairs = function (cost) {
    const n = cost.length;
    const dp = Array(n + 1).fill(0);
    for (let i = 2; i <= n; i++) {
        dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])
    }
    return dp[n]
};
```

## 763. [划分字母区间](https://leetcode-cn.com/problems/partition-labels/)

```txt
一次遍历：map存储给定的字符串中每个字母的最后出现的索引
二次遍历：用双指针 start 和 end：
    (1) 从左到右遍历字符串，遍历的同时维护当前片段的开始下标 start 和结束下标 end，初始时 start = end = 0。

    (2) 对于每个访问到的字母 c，得到当前字母的最后一次出现的下标位置 endc ，则当前片段的结束下标一定不会小于 end ，因此令 end = max{end, endc}

    (3) 当访问到下标 end 时，当前片段访问结束，当前片段的下标范围是 [start, end]，长度为 end − start + 1，将当前片段的长度添加到返回值，然后令 start = end + 1，继续寻找下一个片段。

时间复杂度：O(N)，N 为字符串的长度
空间复杂度：O(Σ)，Σ 为 map 的长度， Σ < N
```

```js
var partitionLabels = function(S) {
    let map = {};
    for (let i=0; i<S.length; i++) {
        map[S[i]] = i
    }
    let res = [];
    let start = 0, end = 0;
    for(let i=0; i<S.length; i++) {
        end = Math.max(end, map[S[i]]);
        if (i === end) {
            res.push(end - start + 1);
            start = end + 1;
        }
    }
    return res;
};
```

## 766. [托普利茨矩阵](https://leetcode-cn.com/problems/toeplitz-matrix/)

```txt
只需要在遍历矩阵的时候判断是不是与其左上角的数一样，若不一样，肯定不是托普利茨矩阵。
```

- 时间复杂度：$O(m*n)$，m 和 n 分别是矩阵的长和宽
- 空间复杂度：$O(1)$

```js
var isToeplitzMatrix = function(matrix) {
    const m = matrix.length;
    const n = matrix[0].length;
    for (let i=1; i<m; i++) {
        for (let j=1; j<n; j++) {
            if (matrix[i][j] !== matrix[i-1][j-1]) return false
        }
    }
    return true
};
```

## 771. [宝石与石头](https://leetcode-cn.com/problems/jewels-and-stones)

- 暴力循环
  
```txt
时间复杂度：O(mn)，其中 m 是字符串 J 的长度，n 是字符串 S 的长度。遍历字符串 S 的时间复杂度是 O(n)，对于 S 中的每个字符，需要遍历字符串 J 判断是否是宝石，时间复杂度是 O(m)，因此总时间复杂度是 O(mn)。
空间复杂度：O(1)，只需要维护常量的额外空间。
```

```js
var numJewelsInStones = function(J, S) {
    let res = 0;
    for(let i=0; i<S.length; i++) {
        let tmp = S[i];
        if (J.indexOf(tmp) !== -1) res++;
    }
    return res;
};
```

- 哈希集合

```txt
时间复杂度：O(m+n)，其中 m 是字符串 J 的长度，n 是字符串 S 的长度。遍历字符串 J 将其中的字符存储到哈希集合中，时间复杂度是 O(m)，然后遍历字符串 S，对于 S 中的每个字符在 O(1) 的时间内判断当前字符是否是宝石，时间复杂度是 O(n)，因此总时间复杂度是 O(m+n)。
空间复杂度：O(m)，其中 m 是字符串 J 的长度。使用哈希集合存储字符串 J 中的字符。
```

```js
var numJewelsInStones = function(J, S) {
    let set = new Set(J.split(''));
    return S.split('').reduce((pre, cur) => {
        return pre + set.has(cur);
    }, 0)
};
```

## 830. [较大分组的位置](https://leetcode-cn.com/problems/positions-of-large-groups/)

```txt
我们可以遍历该序列，并记录当前分组的长度。如果下一个字符与当前字符不同，或者已经枚举到字符串尾部，就说明当前字符为当前分组的尾部。每次找到当前分组的尾部时，如果该分组长度达到 3，我们就将其加入答案。

时间复杂度：O(n)，n 是 s 的长度。
空间复杂度：O(1)
```

```js
var largeGroupPositions = function(s) {
    let res = [];
    const n = s.length;
    let num = 1;
    for (let i = 0; i<n; i++) {
        if (i === n-1 || s[i+1] !== s[i]) {
            if (num >= 3) {
                res.push([i - num + 1, i])
            }
            num = 1;
        } else {
            num++;
        }
    }
    return res
};
```

## 844. [比较含退格的字符串](https://leetcode-cn.com/problems/backspace-string-compare/)

```txt
借助正则，将字母（单个）和 '#' 相连的直接截去，最后再判断一下有没有多余的 '#' ，截去即可。

时间复杂度：O(m + n)， m, n 分别是两个字符串的长度
空间复杂度：O(1)
```

```js
var backspaceCompare = function (S, T) {
    while(S.length !== S.replace(/[a-z][#]/g, "").length) {
        S = S.replace(/[a-z][#]/g, "");
    }
    S = S.replace(/[#]*/g, '');
    while(T.length !== T.replace(/[a-z][#]/g, "").length) {
        T = T.replace(/[a-z][#]/g, "");
    }
    T = T.replace(/[#]*/g, '');
    return S === T
};
```

## 845. [数组中的最长山脉](https://leetcode-cn.com/problems/longest-mountain-in-array/)

```txt
方法1：暴力循环
    遍历循环[1, A.length-1]，一次找出已A[i]为山顶的山脉大小，取最大的那一个
    时间复杂度：O(N*N)
    空间复杂度：O(1)

方法2：动态规划
    我们用 left[i] 表示 A[i] 向左侧最多可以扩展的元素数目。如果 A[i−1]<A[i]，那么 A[i] 可以向左扩展到 A[i−1]，再扩展 left[i] 个元素，
    因此有 left[i] = left[i-1] + 1
    如果 A[i−1] ≥ A[i]，那么 A[i]A[i] 无法向左扩展，因此有 left[i] = 0
    特别地，当 i = 0 时，A[i] 为首元素，无法向左扩展，因此同样有 left[0] = 0
    同理用 right[i] 表示 A[i] 向右侧最多可以扩展的元素数目。
    在计算出所有的 left[] 以及 right[] 之后，我们就可以枚举山顶。
    需要注意的是，只有当 left[i] 和 right[i] 均大于 0 时，A[i] 才能作为山顶，并且山脉的长度为 left[i] + right[i] + 1。
    时间复杂度：O(N)
    空间复杂度：O(N)
```

```js
// 方法1
var longestMountain = function(A) {
    let max = 0, len = A.length;
    for(let i=1; i<len-1; i++) {
        let top = A[i];
        let count = 0;
        if (A[i] > A[i-1] && A[i] > A[i+1]) {
            for(let j=i-1; j>=0 && A[j] < A[j+1]; j--){count++}
            for(let j=i+1; j<len && A[j] < A[j-1]; j++){count++}
            count++;
        }
        max = count > max ? count : max;
    }
    return max
};

// 方法2
var longestMountain = function(A) {
    let n = A.length;
    let left = Array(n), right = Array(n);
    left[0] = 0, right[n-1] = 0;
    for(let i=1; i<n; i++) {
        left[i] = A[i] > A[i-1] ? left[i-1] + 1 : 0;
    }
    for(let i=n-2; i>=0; i--) {
        right[i] = A[i] > A[i+1] ? right[i+1] + 1: 0;
    }
    let res = 0;
    for(let i=0; i<n; i++) {
        if (left[i] > 0 && right[i] > 0) {
            res = Math.max(res, left[i] + right[i] + 1)
        }
    }
    return res;
};
```

## 860. [柠檬水找零](https://leetcode-cn.com/problems/lemonade-change/)

```txt
模拟这个过程就好了，很简单

时间复杂度：O(N)
空间复杂度：O(1)
```

```js
var lemonadeChange = function (bills) {
    let five = 0, ten = 0;
    for (const bill of bills) {
        if (bill === 5) {
            five++;
        } else if (bill === 10) {
            if (five > 0) {
                five--;
                ten++;
            } else return false;
        } else {
            if (five > 0 && ten > 0) {
                five--;
                ten--;
            } else if (five >= 3) {
                five -= 3;
            } else return false;
        }
    }
    return true;    
};
```

## 861. [翻转矩阵后的得分](https://leetcode-cn.com/problems/score-after-flipping-matrix/)

[官网解答](https://leetcode-cn.com/problems/score-after-flipping-matrix/solution/fan-zhuan-ju-zhen-hou-de-de-fen-by-leetc-cxma/)

时间复杂度：O(mn)
空间复杂度：O(1)

```js
var matrixScore = function (A) {
    const m = A.length, n = A[0].length;
    let ans = m * (1 << (n - 1));
    for (let j = 1; j < n; j++) {
        let ones = 0;
        for (let i = 0; i < m; i++) {
            if (A[i][0] === 0) {
                ones += 1 - A[i][j];
            } else {
                ones += A[i][j]
            }
        }
        let k = Math.max(ones, m - ones);
        ans += k * (1 << (n - j - 1))
    }
    return ans
};
```

## 867. [转置矩阵](https://leetcode-cn.com/problems/transpose-matrix/)

```txt
横纵坐标对换位置即可，很简单。
```

- 时间复杂度：$O(m * n)$，其中 $m$ 为矩阵的行数，$n$ 为矩阵的列数。
- 空间复杂度：$O(1)$。除了返回值以外，额外使用的空间为常数。

```js
var transpose = function (matrix) {
    const row = matrix.length;
    const col = matrix[0].length;
    const res = Array(col).fill(0).map(e => Array(row).fill(0));
    for (let i = 0; i < row; i++) {
        for (let j = 0; j < col; j++) {
            res[j][i] = matrix[i][j]
        }
    }
    return res
};
```

## 876. [链表的中间结点](https://leetcode-cn.com/problems/middle-of-the-linked-list)

```txt
思路1:
两次遍历，第一次遍历获取单链表的长度，第二次只要遍历到中间即可。

时间复杂度：O(N)，N 是链表的长度
空间复杂度：O(1)

思路2:
一次遍历：快慢指针，慢指针一次走一步，快指针一次走两步。

时间复杂度：O(N)，N 是链表的长度
空间复杂度：O(1)
```

```js
// 两次遍历
var middleNode = function(head) {
    let p = head;
    let len = 0;
    while(p) {
        len++;
        p = p.next;
    }
    len = len % 2 === 0 ? len / 2 + 1 : Math.floor(len / 2) + 1;
    while(len > 1) { // 这里注意是大于1，比如len=3，head只需要往后移两次，1->2,2->3
        head = head.next;
        len--;
    }
    return head;
};

// 快慢指针
var middleNode = function(head) {
    let slow = head, fast = head;
    while(fast && fast.next) {
        slow = slow.next;
        fast = fast.next.next;
    }
    return slow;
};
```

## 888. [公平的糖果棒交换](https://leetcode-cn.com/problems/fair-candy-swap/)

思路：哈希表

---

这是一个纯数学问题，我们来把它数学化：

假设我们最后得结果是 $[a, b]$，也就是 $a$ 是 $A$ 要交换得，$b$ 是 $B$ 要交换的

我们可以计算分别得到 $A$ 和 $B$ 的和为 $aSum$ 和 $bSum$，那我们会有如下关系：

$$aSum - a + b = bSum - b + a$$

转化一下可以得到：

$$a = b + \frac{aSum - bSum}{2}$$

其实问题就是：对于 $B$ 中的任一数 $b$，在 $A$ 中存在一个数 $a$，满足上述关系式。

---

- 时间复杂度：$O(n+m)$，$n$ 和 $m$ 分别为 $A$ 和 $B$ 的长度。
- 空间复杂度：$O(n)$。

```js
var fairCandySwap = function (A, B) {
    let aSum = A.reduce((preValue, curValue) => preValue + curValue);
    let bSum = B.reduce((preValue, curValue) => preValue + curValue);
    let diff = (aSum - bSum) / 2;
    const set = new Set(A);
    let res = [];
    for (const y of B) {
        let x = y + diff;
        if (set.has(x)) {
            res = [x, y]
            break
        }
    }
    return res
};
```

## 896. [单调数列](https://leetcode-cn.com/problems/monotonic-array/)

```txt
两次遍历，一次判断是否递增，一次判断是否递减。
```

- 时间复杂度：O(N)，其中 N 是数组 A 的长度。
- 空间复杂度：O(1)。

```js
var isMonotonic = function(A) {
    let helper = arr => {
        return arr.slice(1).every((item, index) => arr[index] <= item) // 递增
    }
    return helper(A) || helper(A.reverse())
};
```

## 922. [按奇偶排序数组 II](https://leetcode-cn.com/problems/sort-array-by-parity-ii/)

```txt
为数组的偶数下标部分和奇数下标部分分别维护指针 i, j。随后，在每一步中，如果 A[i] 为奇数，则不断地向前移动 j（每次移动两个单位），直到遇见下一个偶数。此时，可以直接将 A[i] 与 A[j] 交换。我们不断进行这样的过程，最终能够将所有的整数放在正确的位置上。

时间复杂度：O(N)，其中 N 是数组 A 的长度。
空间复杂度：O(1)。
```

```js
var sortArrayByParityII = function(A) {
    let [i, j] = [0, 1];
    while(i < A.length && j < A.length) {
        while(A[i] % 2 === 0) {
            i+=2
        }
        while(A[j] % 2 === 1) {
            j+=2
        }
        if (i < A.length && j < A.length) {
            [A[i], A[j]] = [A[j], A[i]];
        }
    }
    return A;
};
```

## 925. [长按键入](https://leetcode-cn.com/problems/long-pressed-name/)

```txt
用两个指针，一个指向 name 的头部，另一个指向 typed 的头部，遍历无非就两种情况：
（1）name[i] = typed[j] ， 这个时候只要让两个指针同时后移一位，i++; j++;
（2）typed[j] = typed[j-1] ， 这个时候说明是键盘长按，只要让 j 指针后移一位，j++;

不满这两种情况说明都不符合要求

时间复杂度：O(M + N)，
空间复杂度：O(1)
```

```js
var isLongPressedName = function (name, typed) {
    let i = 0, j = 0;
    while(i < name.length || j < typed.length) {
        if (name[i] === typed[j]) {
            i++;
            j++;
        } else if (typed[j] === typed[j-1]) {
            j++;
        } else return false;
    }
    return true;
};
```

## 941. [有效的山脉数组](https://leetcode-cn.com/problems/valid-mountain-array/)

```txt
找到最大的数所在的位置，剔除边界的情况，然后分别判断左边是不是严格递增，右边是不是严格递减

时间复杂度：O(N)
空间复杂度：O(1)
```

```js
var validMountainArray = function(A) {
    if (A.length < 3) return false;
    const index = A.indexOf(Math.max(...A));
    const n = A.length;
    if (index === 0 || index === n - 1) return false;
    for(let i=0; i<index; i++) {
        if (A[i] >= A[i+1]) return false
    }
    for(let j=n-1; j>index; j--) {
        if (A[j] >= A[j-1]) return false;
    }
    return true
};
```

## 973. [最接近原点的 K 个点](https://leetcode-cn.com/problems/k-closest-points-to-origin/)

```txt
简单排序题

时间复杂度：O(NlogN)，排序算法的时间复杂度。
空间复杂度：O(logN)，排序所需额外的空间复杂度为 O(\log n)O(logn)。
```

```js
var kClosest = function(points, K) {
    points.sort((a,b) => Math.pow(a[0], 2) + Math.pow(a[1], 2) - Math.pow(b[0], 2) - Math.pow(b[1], 2));
    return points.slice(0, K)
};
```

## 976. [三角形的最大周长](https://leetcode-cn.com/problems/largest-perimeter-triangle/)

```txt
时间复杂度：O(NlogN)，排序的时间复杂度
空间复杂度：O(logN)，排序的空间复杂度
```

```js
var largestPerimeter = function (A) {
    A.sort((a,b) => b-a)
    for (let i = 0; i < A.length; i++) {
        if (A[i] < A[i + 1] + A[i + 2]) {
            return A[i] + A[i + 1] + A[i + 2]
        }
    }
    return 0
};
```

## 977. [有序数组的平方](https://leetcode-cn.com/problems/squares-of-a-sorted-array/)

```txt
两种思路：
    1. 平方后再对数组排序，时间复杂度：O(NlogN)，空间复杂度：O(logN)
    2. 双指针，start 和 end 头尾指针，向中间缩进，时间复杂度：O(N)，空间复杂度：O(N)
```

```js
var sortedSquares = function(A) {
    // return A.map(e => e * e).sort((a,b) => a-b); // 思路1
    let start = 0, end = A.length - 1;
    let res = [];
    while(start <= end) {
        if (Math.abs(A[start]) >= Math.max(A[end])) {
            res.unshift(A[start] * A[start]);
            start++;
        } else {
            res.unshift(A[end] * A[end]);
            end--;
        }
    }
    return res;
};
```

## 989. [数组形式的整数加法](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)

```txt
把 K 也变成一个数组，两个数组从后往前加

或者不用将 K 变成数组，直接每次取余数就行
```

- 时间复杂度：O($max\{m,n\}$)，其中 m 是数组 A 的长度，n 是数字 K 的长度
- 空间复杂度：O($max\{m,n\}$)。

```js
var addToArrayForm = function(A, K) {
    let kArray = (''+ K).split('').map(Number); // K 转换成数组
    let ret = [];
    let isAdded = 0; // 用来表示进位
    while(kArray.length || A.length) {
        let n1 = A.pop() || 0;
        let n2 = kArray.pop() || 0
        let n = n1 + n2 + isAdded;
        ret.unshift(n % 10);
        isAdded = n >= 10 ? 1 : 0
    }
    if (kArray.length) {
        kArray[kArray.length - 1] += isAdded // kArray 数组有剩余，并且需要对最后一位进行判断是不是需要加 1
        return kArray.concat(ret)
    }
    if (A.length) {
        A[A.length - 1] += isAdded // A 数组有剩余，并且需要对最后一位进行判断是不是需要加 1
        return A.concat(ret)
    }
    if (isAdded) { // 两者都没有剩余 但是有进位，类似 821 + 325
        ret.unshift(1)
    }
    return ret
};

// 每轮遍历的时候让 K 对 10 取余数
var addToArrayForm = function (A, K) {
    let ret = [];
    const n = A.length;
    for (let i = n - 1; i >= 0; --i) {
        let sum = A[i] + K % 10;
        K = Math.floor(K / 10);
        if (sum >= 10) {
            ret.unshift(sum % 10);
            K++;
        } else {
            ret.unshift(sum)
        }
    }
    for (; K > 0; K = Math.floor(K / 10)) {
        ret.unshift(K % 10)
    }
    return ret
};
```

## 1002. [查找常用字符](https://leetcode-cn.com/problems/find-common-characters/)

```txt
我的思路就是其实就是把 A 中的字符求交集
```

```js
var commonChars = function(A) {
    let cross = (a, b) => {
        let res = [];
        for(let s of a) {
            if (b.indexOf(s) !== -1) {
                res.push(s);
                b.splice(b.indexOf(s), 1);
            }
        }
        return res;
    }
    let res = A.pop().split('');
    while(A.length) {
        let a = A.pop().split('');
        res = cross(res, a);
    }
    return res;
};
```

## 1024. [视频拼接](https://leetcode-cn.com/problems/video-stitching/)

```txt
动态规划
dp[i] 定义为 [0, i) 区间内最小的区间数

状态转移方程
对于任意一个符合条件 i ∈ (a, b] 的区间有：
    dp[i] = min{dp[a]} + 1

时间复杂度：O(T * N)，T是区间的长度，N是子区间的数量
空间复杂度：O(T)
```

```js
var videoStitching = function (clips, T) {
    let dp = Array(T + 1).fill(Infinity);
    dp[0] = 0;
    for (let i = 1; i <= T; i++) {
        for (let clip of clips) {
            if (i > clip[0] && i <= clip[1]) {
                dp[i] = Math.min(dp[i], dp[clip[0]] + 1)
            }
        }
    }
    return dp[T] === Infinity ? -1 : dp[T]
};
```

## 1030. [距离顺序排列矩阵单元格](https://leetcode-cn.com/problems/matrix-cells-in-distance-order/)

```txt
直接排序

时间复杂度：O(RClog(RC))，存储所有点时间复杂度 O(RC)，排序时间复杂度 O(RClog(RC))
空间复杂度：O(log(RC))，即为排序需要使用的栈空间，不考虑返回值的空间占用。
```

```js
var allCellsDistOrder = function(R, C, r0, c0) {
    let matrix = [];
    for(let r = 0; r < R; r++) {
        for(let c = 0; c < C; c++) {
            matrix.push([r, c])
        }
    }
    return matrix.sort((a, b) => Math.abs(a[0] - r0) + Math.abs(a[1] - c0) - Math.abs(b[0] - r0) - Math.abs(b[1] - c0))
};
```

## 1046. [最后一块石头的重量](https://leetcode-cn.com/problems/last-stone-weight/)

```txt
我上来就是一个无脑循环

时间复杂度：O(n^2logn)
空间复杂度：O(n)

当然这题可以维护一个最大优先队列来降低实践时间复杂度，自行尝试
```

```js
var lastStoneWeight = function(stones) {
    while (stones.length > 1) {
        stones.sort((a,b) => b-a);
        let x = stones.shift(), y = stones.shift();
        if (x === y) {
            continue
        } else {
            stones.push(x - y)
        }
    }
    return stones.length === 0 ? 0 : stones[0]
};
```

## 1018. [可被 5 整除的二进制前缀](https://leetcode-cn.com/problems/binary-prefix-divisible-by-5/)

```txt
题解：

对数组 [A[0], A[1], A[2]] 模拟一下这个过程： 

    第一个数N1：A[0]，然后对 5 去余判断是否为0
    第二个数N2：A[0] * 2 + A[1]，然后对 5 去余判断是否为0
    第三个数N3：A[0] * 4 + A[1] * 2 + A[2]，然后对 5 去余判断是否为0

我们可以发现 N(i) = N(i-1) * 2 + A[i-1]

但是因为只需要知道 N(i) 是否可以被 5 整除，因而我们可以每一轮只更新 N(i) % 5，结果不会影响，即

N(i) = (N(i-1) * 2 + A[i-1]) % 5
```

- 时间复杂度：O($n$)，其中 n 是数组 A 的长度。
- 空间复杂度：O(1)

```js
var prefixesDivBy5 = function(A) {
    const ret = [];
    let len = A.length;
    let prefix = 0;
    for (let i=0; i<len; i++) {
        prefix = (prefix * 2 + A[i]) % 5;
        ret.push(prefix === 0)
    }
    return ret
};
```

## 1122. [数组的相对排序](https://leetcode-cn.com/problems/relative-sort-array/)

```txt
由于数组 arr2 规定了比较顺序，因此我们可以使用哈希表对该顺序进行映射map。
使用自定义的比较函数：
    - 如果 a 和 b 都出现在哈希表中，那么比较它们对应的值 map.get(a) - map.get(b)；
    - 如果 a 和 b 都没有出现在哈希表中，那么比较它们本身 a - b；
    - 对于剩余的情况，出现在哈希表中的那个元素较小。

时间复杂度：O(mlogm+n)，其中 m 和 n 分别是数组 arr1 和 arr2 的长度。构造哈希表 map 的时间复杂度为 O(n)，排序的时间复杂度为 O(mlogm)

空间复杂度：O(logm+n)，哈希表 map 需要的空间为 O(n)，排序需要的栈空间为 O(logm)。
```

```js
var relativeSortArray = function (arr1, arr2) {
    const map = new Map();
    arr2.forEach((item, index) => {
        map.set(item, index)
    })
    return arr1.sort((a, b) => {
        if (map.has(a) && map.has(b)) {
            return map.get(a) - map.get(b)
        } else if (!map.has(a) && !map.has(b)) {
            return a - b;
        } else if (map.has(a)) {
            return a
        } else {
            return b
        }
    })
};
```

## 1128. [等价多米诺骨牌对的数量](https://leetcode-cn.com/problems/number-of-equivalent-domino-pairs/)

### 方法1：排序 + 哈希map + 计数

```txt
将 dominoes 数组中每一项按从小到大排个序变为字符串，然后哈希表记录下出每个字符串出现的次数，最后遍历哈希表即可得
```

- 时间复杂度：O(n)，n 是数组的长度。
- 空间复杂度：O(n)

```js
var numEquivDominoPairs = function(dominoes) {
    dominoes = dominoes.map(e => e[0] < e[1] ? '' + e[0] + e[1] : '' + e[1] + e[0]);
    let map = new Map();
    for (let dominoe of dominoes) {
        if (map.has(dominoe)) {
            map.set(dominoe, map.get(dominoe) + 1)
        } else {
            map.set(dominoe, 1)
        }
    }
    let ret = 0;
    map.forEach(value => {
        ret += value * (value - 1) / 2
    })
    return ret
};
```

### 方法2：二元组表示 + 计数

```txt
首先我们直接让每一个二元对都变为指定的格式，即第一维必须不大于第二维。这样两个二元对「等价」当且仅当两个二元对完全相同。

其次注意到二元对中的元素均不大于 9，因此我们可以将每一个二元对拼接成一个两位的正整数，即 (x,y) -> 10x+y。
这样就无需使用哈希表统计元素数量，而直接使用长度为 100 的数组即可。
```

- 时间复杂度：O(n)，n 是数组的长度。
- 空间复杂度：O(1)

```js
var numEquivDominoPairs = function (dominoes) {
    let arr = Array(100).fill(0);
    let ret = 0;
    for (const ele of dominoes) {
        let val = ele[0] > ele[1] ? 10 * ele[1] + ele[0] : 10 * ele[0] + ele[1];
        arr[val]++;
    }
    for (const n of arr) {
        ret += n * (n - 1) / 2
    }
    return ret
};
```

## 1207. [独一无二的出现次数](https://leetcode-cn.com/problems/unique-number-of-occurrences/)

```txt
map 记录每个数出现的次数，然后用集合判断有没有重复数字即可

时间复杂度：O(N)
空间复杂度：O(N)
```

```js
var uniqueOccurrences = function(arr) {
    let map = {};
    arr.forEach((item) => {
        if (map[item] === undefined) {
            map[item] = 1
        } else {
            map[item]++
        }
    });
    let a = Object.values(map)
    return [...new Set(a)].length === a.length
};
```

## 1356. [根据数字二进制下 1 的数目排序](https://leetcode-cn.com/problems/sort-integers-by-the-number-of-1-bits/)

```txt
就是一个特定要求的排序

时间复杂度：O(NlogN)
空间复杂度：O(N)
```

```js
var sortByBits = function(arr) {
    return arr.sort((a, b) => {
        let n1 = a.toString(2).split('').filter(e => e === '1').length;
        let n2 = b.toString(2).split('').filter(e => e === '1').length;
        if (n1 === n2) {
            return a - b;
        } else {
            return n1 - n2;
        }
    })
};
```

## 1365. [有多少小于当前数字的数字](https://leetcode-cn.com/problems/how-many-numbers-are-smaller-than-the-current-number/)

```txt
方法1：
    暴力循环，时间复杂度:O(N*N)，空间复杂度:O(N)

方法2：
    计数排序，注意到数组元素的值域为 [0,100]，所以可以考虑建立一个频次数组 cnt ，cnt[i] 表示数字 i 出现的次数。那么对于数字 i 而言，小于它的数目就为 cnt[0...i−1] 的总和。
    时间复杂度：O(N + K)，其中 K 为值域大小。需要遍历两次原数组，同时遍历一次频次数组 cnt 找出前缀和。
    空间复杂度：O(K)。因为要额外开辟一个值域大小的数组。。
```

```js
// 方法1
var smallerNumbersThanCurrent = function(nums) {
    let res = Array(nums.length).fill(0);
    for(let i = 0; i < nums.length; i++) {
        for(let j=0; j < nums.length; j++) {
            if (nums[j] < nums[i]  && j !== i) {
                res[i] += 1;
            }
        }
    }
    return res;
};

// 方法2
var smallerNumbersThanCurrent = function (nums) {
    const n = nums.length;
    let cnt = Array(101).fill(0);
    for (i = 0; i < n; i++) {
        cnt[nums[i]]++;
    }
    for (let i = 1; i < 101; i++) {
        cnt[i] += cnt[i - 1]
    }
    let ans = [];
    for (let i = 0; i < n; i++) {
        ans[i] = nums[i] === 0 ? 0 : cnt[nums[i] - 1]
    }
    return ans
};
```

## 1370. [上升下降字符串](https://leetcode-cn.com/problems/increasing-decreasing-string/)

```txt
桶排序，arr 是一个长度为 26 大小的数组，里面保存着 s 中 a-z 的次数
题目的要求其实就是先找从小到大的再找从大到小的，也就是将arr数组先正序找到存在的，再逆序找到存在的

时间复杂度：O(26 * N)，N 为字符串 s 的长度
空间复杂度：O(26)
```

```js
var sortString = function (s) {
    let arr = Array(26).fill(0);
    for (let ch of s) {
        arr[ch.charCodeAt() - 'a'.charCodeAt()]++;
    }
    let ans = '';
    while (ans.length < s.length) {
        for (let i = 0; i < 26; i++) {
            if (arr[i]) {
                ans += String.fromCharCode(i + 'a'.charCodeAt())
                arr[i]--;
            }
        }
        for (let i = 25; i >= 0; i--) {
            if (arr[i]) {
                ans += String.fromCharCode(i + 'a'.charCodeAt())
                arr[i]--;
            }
        }
    }
    return ans
};
```

## 1423. [可获得的最大点数](https://leetcode-cn.com/problems/maximum-points-you-can-obtain-from-cards/)

```txt
本题我们可以借助滑动窗口

题目要求限制我们只能从开头或结尾拿数字，那么最后剩下的数字一定是连续的，滑动窗口长度为数组的长度减去我们要拿的卡牌数

这样我们可以反向思维，我们找到连续数字和最小的这个滑动窗口即可

滑动窗口的长度:windowSize = cardPoints.length - k
```

- 时间复杂度：O(n)，其中 n 是数组 cardPoints 的长度。
- 空间复杂度：O(1)

```js
var maxScore = function (cardPoints, k) {
    const n = cardPoints.length;
    // 所有数字之和
    let total = cardPoints.reduce((preVal, curVal) => preVal + curVal);
    let windowSize = n - k;
    // 算出起始滑动窗口中数字之和
    let sum = 0;
    for (let i = 0; i < windowSize; i++) {
        sum += cardPoints[i]
    }
    // 维护一个变量 min 保存滑动窗口中数字之和的最小值
    let min = sum;
    for (let j = windowSize; j < n; j++) {
        sum = sum - cardPoints[j-windowSize] + cardPoints[j];
        min = Math.min(min, sum)
    }
    return total - min
};
print(hello world);

```
